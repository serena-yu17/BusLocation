// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace TransitRealtime
{
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class GTFSRealtime
    {
        #region Extension registration
        public static void RegisterAllExtensions(pb::ExtensionRegistry registry)
        {
        }
        #endregion
        #region Static variables
        internal static pbd::MessageDescriptor internal__static_transit_realtime_FeedMessage__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.FeedMessage, global::TransitRealtime.FeedMessage.Builder> internal__static_transit_realtime_FeedMessage__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_FeedHeader__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.FeedHeader, global::TransitRealtime.FeedHeader.Builder> internal__static_transit_realtime_FeedHeader__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_FeedEntity__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.FeedEntity, global::TransitRealtime.FeedEntity.Builder> internal__static_transit_realtime_FeedEntity__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripUpdate__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripUpdate, global::TransitRealtime.TripUpdate.Builder> internal__static_transit_realtime_TripUpdate__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripUpdate.Types.StopTimeEvent, global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Builder> internal__static_transit_realtime_TripUpdate_StopTimeEvent__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Builder> internal__static_transit_realtime_TripUpdate_StopTimeUpdate__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_VehiclePosition__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.VehiclePosition, global::TransitRealtime.VehiclePosition.Builder> internal__static_transit_realtime_VehiclePosition__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_Alert__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.Alert, global::TransitRealtime.Alert.Builder> internal__static_transit_realtime_Alert__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TimeRange__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TimeRange, global::TransitRealtime.TimeRange.Builder> internal__static_transit_realtime_TimeRange__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_Position__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.Position, global::TransitRealtime.Position.Builder> internal__static_transit_realtime_Position__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TripDescriptor__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripDescriptor, global::TransitRealtime.TripDescriptor.Builder> internal__static_transit_realtime_TripDescriptor__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_VehicleDescriptor__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.VehicleDescriptor, global::TransitRealtime.VehicleDescriptor.Builder> internal__static_transit_realtime_VehicleDescriptor__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_EntitySelector__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.EntitySelector, global::TransitRealtime.EntitySelector.Builder> internal__static_transit_realtime_EntitySelector__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TranslatedString__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TranslatedString, global::TransitRealtime.TranslatedString.Builder> internal__static_transit_realtime_TranslatedString__FieldAccessorTable;
        internal static pbd::MessageDescriptor internal__static_transit_realtime_TranslatedString_Translation__Descriptor;
        internal static pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TranslatedString.Types.Translation, global::TransitRealtime.TranslatedString.Types.Translation.Builder> internal__static_transit_realtime_TranslatedString_Translation__FieldAccessorTable;
        #endregion
        #region Descriptor
        public static pbd::FileDescriptor Descriptor
        {
            get { return descriptor; }
        }
        private static pbd::FileDescriptor descriptor;

        static GTFSRealtime()
        {
            byte[] descriptorData = global::System.Convert.FromBase64String(
                string.Concat(
                  "ChNndGZzLXJlYWx0aW1lLnByb3RvEhB0cmFuc2l0X3JlYWx0aW1lInEKC0Zl",
                  "ZWRNZXNzYWdlEiwKBmhlYWRlchgBIAIoCzIcLnRyYW5zaXRfcmVhbHRpbWUu",
                  "RmVlZEhlYWRlchIsCgZlbnRpdHkYAiADKAsyHC50cmFuc2l0X3JlYWx0aW1l",
                  "LkZlZWRFbnRpdHkqBgjoBxDQDyLPAQoKRmVlZEhlYWRlchIdChVndGZzX3Jl",
                  "YWx0aW1lX3ZlcnNpb24YASACKAkSUQoOaW5jcmVtZW50YWxpdHkYAiABKA4y",
                  "Ky50cmFuc2l0X3JlYWx0aW1lLkZlZWRIZWFkZXIuSW5jcmVtZW50YWxpdHk6",
                  "DEZVTExfREFUQVNFVBIRCgl0aW1lc3RhbXAYAyABKAQiNAoOSW5jcmVtZW50",
                  "YWxpdHkSEAoMRlVMTF9EQVRBU0VUEAASEAoMRElGRkVSRU5USUFMEAEqBgjo",
                  "BxDQDyLKAQoKRmVlZEVudGl0eRIKCgJpZBgBIAIoCRIZCgppc19kZWxldGVk",
                  "GAIgASgIOgVmYWxzZRIxCgt0cmlwX3VwZGF0ZRgDIAEoCzIcLnRyYW5zaXRf",
                  "cmVhbHRpbWUuVHJpcFVwZGF0ZRIyCgd2ZWhpY2xlGAQgASgLMiEudHJhbnNp",
                  "dF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24SJgoFYWxlcnQYBSABKAsyFy50",
                  "cmFuc2l0X3JlYWx0aW1lLkFsZXJ0KgYI6AcQ0A8imgUKClRyaXBVcGRhdGUS",
                  "LgoEdHJpcBgBIAIoCzIgLnRyYW5zaXRfcmVhbHRpbWUuVHJpcERlc2NyaXB0",
                  "b3ISNAoHdmVoaWNsZRgDIAEoCzIjLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNs",
                  "ZURlc2NyaXB0b3ISRQoQc3RvcF90aW1lX3VwZGF0ZRgCIAMoCzIrLnRyYW5z",
                  "aXRfcmVhbHRpbWUuVHJpcFVwZGF0ZS5TdG9wVGltZVVwZGF0ZRIRCgl0aW1l",
                  "c3RhbXAYBCABKAQSDQoFZGVsYXkYBSABKAUaSQoNU3RvcFRpbWVFdmVudBIN",
                  "CgVkZWxheRgBIAEoBRIMCgR0aW1lGAIgASgDEhMKC3VuY2VydGFpbnR5GAMg",
                  "ASgFKgYI6AcQ0A8a6QIKDlN0b3BUaW1lVXBkYXRlEhUKDXN0b3Bfc2VxdWVu",
                  "Y2UYASABKA0SDwoHc3RvcF9pZBgEIAEoCRI7CgdhcnJpdmFsGAIgASgLMiou",
                  "dHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lRXZlbnQSPQoJ",
                  "ZGVwYXJ0dXJlGAMgASgLMioudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRl",
                  "LlN0b3BUaW1lRXZlbnQSagoVc2NoZWR1bGVfcmVsYXRpb25zaGlwGAUgASgO",
                  "MkAudHJhbnNpdF9yZWFsdGltZS5UcmlwVXBkYXRlLlN0b3BUaW1lVXBkYXRl",
                  "LlNjaGVkdWxlUmVsYXRpb25zaGlwOglTQ0hFRFVMRUQiPwoUU2NoZWR1bGVS",
                  "ZWxhdGlvbnNoaXASDQoJU0NIRURVTEVEEAASCwoHU0tJUFBFRBABEgsKB05P",
                  "X0RBVEEQAioGCOgHENAPKgYI6AcQ0A8i4AYKD1ZlaGljbGVQb3NpdGlvbhIu",
                  "CgR0cmlwGAEgASgLMiAudHJhbnNpdF9yZWFsdGltZS5UcmlwRGVzY3JpcHRv",
                  "chI0Cgd2ZWhpY2xlGAggASgLMiMudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xl",
                  "RGVzY3JpcHRvchIsCghwb3NpdGlvbhgCIAEoCzIaLnRyYW5zaXRfcmVhbHRp",
                  "bWUuUG9zaXRpb24SHQoVY3VycmVudF9zdG9wX3NlcXVlbmNlGAMgASgNEg8K",
                  "B3N0b3BfaWQYByABKAkSWgoOY3VycmVudF9zdGF0dXMYBCABKA4yMy50cmFu",
                  "c2l0X3JlYWx0aW1lLlZlaGljbGVQb3NpdGlvbi5WZWhpY2xlU3RvcFN0YXR1",
                  "czoNSU5fVFJBTlNJVF9UTxIRCgl0aW1lc3RhbXAYBSABKAQSSwoQY29uZ2Vz",
                  "dGlvbl9sZXZlbBgGIAEoDjIxLnRyYW5zaXRfcmVhbHRpbWUuVmVoaWNsZVBv",
                  "c2l0aW9uLkNvbmdlc3Rpb25MZXZlbBJLChBvY2N1cGFuY3lfc3RhdHVzGAkg",
                  "ASgOMjEudHJhbnNpdF9yZWFsdGltZS5WZWhpY2xlUG9zaXRpb24uT2NjdXBh",
                  "bmN5U3RhdHVzIkcKEVZlaGljbGVTdG9wU3RhdHVzEg8KC0lOQ09NSU5HX0FU",
                  "EAASDgoKU1RPUFBFRF9BVBABEhEKDUlOX1RSQU5TSVRfVE8QAiJ9Cg9Db25n",
                  "ZXN0aW9uTGV2ZWwSHAoYVU5LTk9XTl9DT05HRVNUSU9OX0xFVkVMEAASFAoQ",
                  "UlVOTklOR19TTU9PVEhMWRABEg8KC1NUT1BfQU5EX0dPEAISDgoKQ09OR0VT",
                  "VElPThADEhUKEVNFVkVSRV9DT05HRVNUSU9OEAQirwEKD09jY3VwYW5jeVN0",
                  "YXR1cxIJCgVFTVBUWRAAEhgKFE1BTllfU0VBVFNfQVZBSUxBQkxFEAESFwoT",
                  "RkVXX1NFQVRTX0FWQUlMQUJMRRACEhYKElNUQU5ESU5HX1JPT01fT05MWRAD",
                  "Eh4KGkNSVVNIRURfU1RBTkRJTkdfUk9PTV9PTkxZEAQSCAoERlVMTBAFEhwK",
                  "GE5PVF9BQ0NFUFRJTkdfUEFTU0VOR0VSUxAGKgYI6AcQ0A8itgYKBUFsZXJ0",
                  "EjIKDWFjdGl2ZV9wZXJpb2QYASADKAsyGy50cmFuc2l0X3JlYWx0aW1lLlRp",
                  "bWVSYW5nZRI5Cg9pbmZvcm1lZF9lbnRpdHkYBSADKAsyIC50cmFuc2l0X3Jl",
                  "YWx0aW1lLkVudGl0eVNlbGVjdG9yEjsKBWNhdXNlGAYgASgOMh0udHJhbnNp",
                  "dF9yZWFsdGltZS5BbGVydC5DYXVzZToNVU5LTk9XTl9DQVVTRRI+CgZlZmZl",
                  "Y3QYByABKA4yHi50cmFuc2l0X3JlYWx0aW1lLkFsZXJ0LkVmZmVjdDoOVU5L",
                  "Tk9XTl9FRkZFQ1QSLwoDdXJsGAggASgLMiIudHJhbnNpdF9yZWFsdGltZS5U",
                  "cmFuc2xhdGVkU3RyaW5nEjcKC2hlYWRlcl90ZXh0GAogASgLMiIudHJhbnNp",
                  "dF9yZWFsdGltZS5UcmFuc2xhdGVkU3RyaW5nEjwKEGRlc2NyaXB0aW9uX3Rl",
                  "eHQYCyABKAsyIi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmci",
                  "2AEKBUNhdXNlEhEKDVVOS05PV05fQ0FVU0UQARIPCgtPVEhFUl9DQVVTRRAC",
                  "EhUKEVRFQ0hOSUNBTF9QUk9CTEVNEAMSCgoGU1RSSUtFEAQSEQoNREVNT05T",
                  "VFJBVElPThAFEgwKCEFDQ0lERU5UEAYSCwoHSE9MSURBWRAHEgsKB1dFQVRI",
                  "RVIQCBIPCgtNQUlOVEVOQU5DRRAJEhAKDENPTlNUUlVDVElPThAKEhMKD1BP",
                  "TElDRV9BQ1RJVklUWRALEhUKEU1FRElDQUxfRU1FUkdFTkNZEAwitQEKBkVm",
                  "ZmVjdBIOCgpOT19TRVJWSUNFEAESEwoPUkVEVUNFRF9TRVJWSUNFEAISFgoS",
                  "U0lHTklGSUNBTlRfREVMQVlTEAMSCgoGREVUT1VSEAQSFgoSQURESVRJT05B",
                  "TF9TRVJWSUNFEAUSFAoQTU9ESUZJRURfU0VSVklDRRAGEhAKDE9USEVSX0VG",
                  "RkVDVBAHEhIKDlVOS05PV05fRUZGRUNUEAgSDgoKU1RPUF9NT1ZFRBAJKgYI",
                  "6AcQ0A8iLwoJVGltZVJhbmdlEg0KBXN0YXJ0GAEgASgEEgsKA2VuZBgCIAEo",
                  "BCoGCOgHENAPImkKCFBvc2l0aW9uEhAKCGxhdGl0dWRlGAEgAigCEhEKCWxv",
                  "bmdpdHVkZRgCIAIoAhIPCgdiZWFyaW5nGAMgASgCEhAKCG9kb21ldGVyGAQg",
                  "ASgBEg0KBXNwZWVkGAUgASgCKgYI6AcQ0A8ioAIKDlRyaXBEZXNjcmlwdG9y",
                  "Eg8KB3RyaXBfaWQYASABKAkSEAoIcm91dGVfaWQYBSABKAkSFAoMZGlyZWN0",
                  "aW9uX2lkGAYgASgNEhIKCnN0YXJ0X3RpbWUYAiABKAkSEgoKc3RhcnRfZGF0",
                  "ZRgDIAEoCRJUChVzY2hlZHVsZV9yZWxhdGlvbnNoaXAYBCABKA4yNS50cmFu",
                  "c2l0X3JlYWx0aW1lLlRyaXBEZXNjcmlwdG9yLlNjaGVkdWxlUmVsYXRpb25z",
                  "aGlwIk8KFFNjaGVkdWxlUmVsYXRpb25zaGlwEg0KCVNDSEVEVUxFRBAAEgkK",
                  "BUFEREVEEAESDwoLVU5TQ0hFRFVMRUQQAhIMCghDQU5DRUxFRBADKgYI6AcQ",
                  "0A8iTQoRVmVoaWNsZURlc2NyaXB0b3ISCgoCaWQYASABKAkSDQoFbGFiZWwY",
                  "AiABKAkSFQoNbGljZW5zZV9wbGF0ZRgDIAEoCSoGCOgHENAPIpIBCg5FbnRp",
                  "dHlTZWxlY3RvchIRCglhZ2VuY3lfaWQYASABKAkSEAoIcm91dGVfaWQYAiAB",
                  "KAkSEgoKcm91dGVfdHlwZRgDIAEoBRIuCgR0cmlwGAQgASgLMiAudHJhbnNp",
                  "dF9yZWFsdGltZS5UcmlwRGVzY3JpcHRvchIPCgdzdG9wX2lkGAUgASgJKgYI",
                  "6AcQ0A8ilgEKEFRyYW5zbGF0ZWRTdHJpbmcSQwoLdHJhbnNsYXRpb24YASAD",
                  "KAsyLi50cmFuc2l0X3JlYWx0aW1lLlRyYW5zbGF0ZWRTdHJpbmcuVHJhbnNs",
                  "YXRpb24aNQoLVHJhbnNsYXRpb24SDAoEdGV4dBgBIAIoCRIQCghsYW5ndWFn",
                  "ZRgCIAEoCSoGCOgHENAPKgYI6AcQ0A9CHQobY29tLmdvb2dsZS50cmFuc2l0",
                "LnJlYWx0aW1l"));
            pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate (pbd::FileDescriptor root)
            {
                descriptor = root;
                internal__static_transit_realtime_FeedMessage__Descriptor = Descriptor.MessageTypes[0];
                internal__static_transit_realtime_FeedMessage__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.FeedMessage, global::TransitRealtime.FeedMessage.Builder>(internal__static_transit_realtime_FeedMessage__Descriptor,
                        new string[] { "Header", "Entity", });
                internal__static_transit_realtime_FeedHeader__Descriptor = Descriptor.MessageTypes[1];
                internal__static_transit_realtime_FeedHeader__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.FeedHeader, global::TransitRealtime.FeedHeader.Builder>(internal__static_transit_realtime_FeedHeader__Descriptor,
                        new string[] { "GtfsRealtimeVersion", "Incrementality", "Timestamp", });
                internal__static_transit_realtime_FeedEntity__Descriptor = Descriptor.MessageTypes[2];
                internal__static_transit_realtime_FeedEntity__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.FeedEntity, global::TransitRealtime.FeedEntity.Builder>(internal__static_transit_realtime_FeedEntity__Descriptor,
                        new string[] { "Id", "IsDeleted", "TripUpdate", "Vehicle", "Alert", });
                internal__static_transit_realtime_TripUpdate__Descriptor = Descriptor.MessageTypes[3];
                internal__static_transit_realtime_TripUpdate__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripUpdate, global::TransitRealtime.TripUpdate.Builder>(internal__static_transit_realtime_TripUpdate__Descriptor,
                        new string[] { "Trip", "Vehicle", "StopTimeUpdate", "Timestamp", "Delay", });
                internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor = internal__static_transit_realtime_TripUpdate__Descriptor.NestedTypes[0];
                internal__static_transit_realtime_TripUpdate_StopTimeEvent__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripUpdate.Types.StopTimeEvent, global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Builder>(internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor,
                        new string[] { "Delay", "Time", "Uncertainty", });
                internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor = internal__static_transit_realtime_TripUpdate__Descriptor.NestedTypes[1];
                internal__static_transit_realtime_TripUpdate_StopTimeUpdate__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Builder>(internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor,
                        new string[] { "StopSequence", "StopId", "Arrival", "Departure", "ScheduleRelationship", });
                internal__static_transit_realtime_VehiclePosition__Descriptor = Descriptor.MessageTypes[4];
                internal__static_transit_realtime_VehiclePosition__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.VehiclePosition, global::TransitRealtime.VehiclePosition.Builder>(internal__static_transit_realtime_VehiclePosition__Descriptor,
                        new string[] { "Trip", "Vehicle", "Position", "CurrentStopSequence", "StopId", "CurrentStatus", "Timestamp", "CongestionLevel", "OccupancyStatus", });
                internal__static_transit_realtime_Alert__Descriptor = Descriptor.MessageTypes[5];
                internal__static_transit_realtime_Alert__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.Alert, global::TransitRealtime.Alert.Builder>(internal__static_transit_realtime_Alert__Descriptor,
                        new string[] { "ActivePeriod", "InformedEntity", "Cause", "Effect", "Url", "HeaderText", "DescriptionText", });
                internal__static_transit_realtime_TimeRange__Descriptor = Descriptor.MessageTypes[6];
                internal__static_transit_realtime_TimeRange__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TimeRange, global::TransitRealtime.TimeRange.Builder>(internal__static_transit_realtime_TimeRange__Descriptor,
                        new string[] { "Start", "End", });
                internal__static_transit_realtime_Position__Descriptor = Descriptor.MessageTypes[7];
                internal__static_transit_realtime_Position__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.Position, global::TransitRealtime.Position.Builder>(internal__static_transit_realtime_Position__Descriptor,
                        new string[] { "Latitude", "Longitude", "Bearing", "Odometer", "Speed", });
                internal__static_transit_realtime_TripDescriptor__Descriptor = Descriptor.MessageTypes[8];
                internal__static_transit_realtime_TripDescriptor__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TripDescriptor, global::TransitRealtime.TripDescriptor.Builder>(internal__static_transit_realtime_TripDescriptor__Descriptor,
                        new string[] { "TripId", "RouteId", "DirectionId", "StartTime", "StartDate", "ScheduleRelationship", });
                internal__static_transit_realtime_VehicleDescriptor__Descriptor = Descriptor.MessageTypes[9];
                internal__static_transit_realtime_VehicleDescriptor__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.VehicleDescriptor, global::TransitRealtime.VehicleDescriptor.Builder>(internal__static_transit_realtime_VehicleDescriptor__Descriptor,
                        new string[] { "Id", "Label", "LicensePlate", });
                internal__static_transit_realtime_EntitySelector__Descriptor = Descriptor.MessageTypes[10];
                internal__static_transit_realtime_EntitySelector__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.EntitySelector, global::TransitRealtime.EntitySelector.Builder>(internal__static_transit_realtime_EntitySelector__Descriptor,
                        new string[] { "AgencyId", "RouteId", "RouteType", "Trip", "StopId", });
                internal__static_transit_realtime_TranslatedString__Descriptor = Descriptor.MessageTypes[11];
                internal__static_transit_realtime_TranslatedString__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TranslatedString, global::TransitRealtime.TranslatedString.Builder>(internal__static_transit_realtime_TranslatedString__Descriptor,
                        new string[] { "Translation", });
                internal__static_transit_realtime_TranslatedString_Translation__Descriptor = internal__static_transit_realtime_TranslatedString__Descriptor.NestedTypes[0];
                internal__static_transit_realtime_TranslatedString_Translation__FieldAccessorTable =
                    new pb::FieldAccess.FieldAccessorTable<global::TransitRealtime.TranslatedString.Types.Translation, global::TransitRealtime.TranslatedString.Types.Translation.Builder>(internal__static_transit_realtime_TranslatedString_Translation__Descriptor,
                        new string[] { "Text", "Language", });
                return null;
            };
            pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
                new pbd::FileDescriptor[] {
                }, assigner);
        }
        #endregion

    }
    #region Messages
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class FeedMessage : pb::ExtendableMessage<FeedMessage, FeedMessage.Builder>
    {
        private FeedMessage() { }
        private static readonly FeedMessage defaultInstance = new FeedMessage().MakeReadOnly();
        private static readonly string[] _feedMessageFieldNames = new string[] { "entity", "header" };
        private static readonly uint[] _feedMessageFieldTags = new uint[] { 18, 10 };
        public static FeedMessage DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override FeedMessage DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override FeedMessage ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_FeedMessage__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<FeedMessage, FeedMessage.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_FeedMessage__FieldAccessorTable; }
        }

        public const int HeaderFieldNumber = 1;
        private bool hasHeader;
        private global::TransitRealtime.FeedHeader header_;
        public bool HasHeader
        {
            get { return hasHeader; }
        }
        public global::TransitRealtime.FeedHeader Header
        {
            get { return header_ ?? global::TransitRealtime.FeedHeader.DefaultInstance; }
        }

        public const int EntityFieldNumber = 2;
        private pbc::PopsicleList<global::TransitRealtime.FeedEntity> entity_ = new pbc::PopsicleList<global::TransitRealtime.FeedEntity>();
        public scg::IList<global::TransitRealtime.FeedEntity> EntityList
        {
            get { return entity_; }
        }
        public int EntityCount
        {
            get { return entity_.Count; }
        }
        public global::TransitRealtime.FeedEntity GetEntity(int index)
        {
            return entity_[index];
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasHeader) return false;
                if (!Header.IsInitialized) return false;
                foreach (global::TransitRealtime.FeedEntity element in EntityList)
                {
                    if (!element.IsInitialized) return false;
                }
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _feedMessageFieldNames;
            pb::ExtendableMessage<FeedMessage, FeedMessage.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasHeader)
            {
                output.WriteMessage(1, field_names[1], Header);
            }
            if (entity_.Count > 0)
            {
                output.WriteMessageArray(2, field_names[0], entity_);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasHeader)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(1, Header);
            }
            foreach (global::TransitRealtime.FeedEntity element in EntityList)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(2, element);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static FeedMessage ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static FeedMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static FeedMessage ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static FeedMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static FeedMessage ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static FeedMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static FeedMessage ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static FeedMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static FeedMessage ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static FeedMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private FeedMessage MakeReadOnly()
        {
            entity_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(FeedMessage prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<FeedMessage, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(FeedMessage cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private FeedMessage result;

            private FeedMessage PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    FeedMessage original = result;
                    result = new FeedMessage();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override FeedMessage MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.FeedMessage.Descriptor; }
            }

            public override FeedMessage DefaultInstanceForType
            {
                get { return global::TransitRealtime.FeedMessage.DefaultInstance; }
            }

            public override FeedMessage BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is FeedMessage)
                {
                    return MergeFrom((FeedMessage)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(FeedMessage other)
            {
                if (other == global::TransitRealtime.FeedMessage.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasHeader)
                {
                    MergeHeader(other.Header);
                }
                if (other.entity_.Count != 0)
                {
                    result.entity_.Add(other.entity_);
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_feedMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _feedMessageFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                global::TransitRealtime.FeedHeader.Builder subBuilder = global::TransitRealtime.FeedHeader.CreateBuilder();
                                if (result.hasHeader)
                                {
                                    subBuilder.MergeFrom(Header);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Header = subBuilder.BuildPartial();
                                break;
                            }
                        case 18:
                            {
                                input.ReadMessageArray(tag, field_name, result.entity_, global::TransitRealtime.FeedEntity.DefaultInstance, extensionRegistry);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasHeader
            {
                get { return result.hasHeader; }
            }
            public global::TransitRealtime.FeedHeader Header
            {
                get { return result.Header; }
                set { SetHeader(value); }
            }
            public Builder SetHeader(global::TransitRealtime.FeedHeader value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasHeader = true;
                result.header_ = value;
                return this;
            }
            public Builder SetHeader(global::TransitRealtime.FeedHeader.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasHeader = true;
                result.header_ = builderForValue.Build();
                return this;
            }
            public Builder MergeHeader(global::TransitRealtime.FeedHeader value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasHeader &&
                    result.header_ != global::TransitRealtime.FeedHeader.DefaultInstance)
                {
                    result.header_ = global::TransitRealtime.FeedHeader.CreateBuilder(result.header_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.header_ = value;
                }
                result.hasHeader = true;
                return this;
            }
            public Builder ClearHeader()
            {
                PrepareBuilder();
                result.hasHeader = false;
                result.header_ = null;
                return this;
            }

            public pbc::IPopsicleList<global::TransitRealtime.FeedEntity> EntityList
            {
                get { return PrepareBuilder().entity_; }
            }
            public int EntityCount
            {
                get { return result.EntityCount; }
            }
            public global::TransitRealtime.FeedEntity GetEntity(int index)
            {
                return result.GetEntity(index);
            }
            public Builder SetEntity(int index, global::TransitRealtime.FeedEntity value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.entity_[index] = value;
                return this;
            }
            public Builder SetEntity(int index, global::TransitRealtime.FeedEntity.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.entity_[index] = builderForValue.Build();
                return this;
            }
            public Builder AddEntity(global::TransitRealtime.FeedEntity value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.entity_.Add(value);
                return this;
            }
            public Builder AddEntity(global::TransitRealtime.FeedEntity.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.entity_.Add(builderForValue.Build());
                return this;
            }
            public Builder AddRangeEntity(scg::IEnumerable<global::TransitRealtime.FeedEntity> values)
            {
                PrepareBuilder();
                result.entity_.Add(values);
                return this;
            }
            public Builder ClearEntity()
            {
                PrepareBuilder();
                result.entity_.Clear();
                return this;
            }
        }
        static FeedMessage()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class FeedHeader : pb::ExtendableMessage<FeedHeader, FeedHeader.Builder>
    {
        private FeedHeader() { }
        private static readonly FeedHeader defaultInstance = new FeedHeader().MakeReadOnly();
        private static readonly string[] _feedHeaderFieldNames = new string[] { "gtfs_realtime_version", "incrementality", "timestamp" };
        private static readonly uint[] _feedHeaderFieldTags = new uint[] { 10, 16, 24 };
        public static FeedHeader DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override FeedHeader DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override FeedHeader ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_FeedHeader__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<FeedHeader, FeedHeader.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_FeedHeader__FieldAccessorTable; }
        }

        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum Incrementality
            {
                FULL_DATASET = 0,
                DIFFERENTIAL = 1,
            }

        }
        #endregion

        public const int GtfsRealtimeVersionFieldNumber = 1;
        private bool hasGtfsRealtimeVersion;
        private string gtfsRealtimeVersion_ = "";
        public bool HasGtfsRealtimeVersion
        {
            get { return hasGtfsRealtimeVersion; }
        }
        public string GtfsRealtimeVersion
        {
            get { return gtfsRealtimeVersion_; }
        }

        public const int IncrementalityFieldNumber = 2;
        private bool hasIncrementality;
        private global::TransitRealtime.FeedHeader.Types.Incrementality incrementality_ = global::TransitRealtime.FeedHeader.Types.Incrementality.FULL_DATASET;
        public bool HasIncrementality
        {
            get { return hasIncrementality; }
        }
        public global::TransitRealtime.FeedHeader.Types.Incrementality Incrementality
        {
            get { return incrementality_; }
        }

        public const int TimestampFieldNumber = 3;
        private bool hasTimestamp;
        private ulong timestamp_;
        public bool HasTimestamp
        {
            get { return hasTimestamp; }
        }
        [global::System.CLSCompliant(false)]
        public ulong Timestamp
        {
            get { return timestamp_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasGtfsRealtimeVersion) return false;
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _feedHeaderFieldNames;
            pb::ExtendableMessage<FeedHeader, FeedHeader.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasGtfsRealtimeVersion)
            {
                output.WriteString(1, field_names[0], GtfsRealtimeVersion);
            }
            if (hasIncrementality)
            {
                output.WriteEnum(2, field_names[1], (int)Incrementality, Incrementality);
            }
            if (hasTimestamp)
            {
                output.WriteUInt64(3, field_names[2], Timestamp);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasGtfsRealtimeVersion)
            {
                size += pb::CodedOutputStream.ComputeStringSize(1, GtfsRealtimeVersion);
            }
            if (hasIncrementality)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(2, (int)Incrementality);
            }
            if (hasTimestamp)
            {
                size += pb::CodedOutputStream.ComputeUInt64Size(3, Timestamp);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static FeedHeader ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static FeedHeader ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static FeedHeader ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static FeedHeader ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static FeedHeader ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static FeedHeader ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static FeedHeader ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static FeedHeader ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static FeedHeader ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static FeedHeader ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private FeedHeader MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(FeedHeader prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<FeedHeader, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(FeedHeader cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private FeedHeader result;

            private FeedHeader PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    FeedHeader original = result;
                    result = new FeedHeader();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override FeedHeader MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.FeedHeader.Descriptor; }
            }

            public override FeedHeader DefaultInstanceForType
            {
                get { return global::TransitRealtime.FeedHeader.DefaultInstance; }
            }

            public override FeedHeader BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is FeedHeader)
                {
                    return MergeFrom((FeedHeader)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(FeedHeader other)
            {
                if (other == global::TransitRealtime.FeedHeader.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasGtfsRealtimeVersion)
                {
                    GtfsRealtimeVersion = other.GtfsRealtimeVersion;
                }
                if (other.HasIncrementality)
                {
                    Incrementality = other.Incrementality;
                }
                if (other.HasTimestamp)
                {
                    Timestamp = other.Timestamp;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_feedHeaderFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _feedHeaderFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                result.hasGtfsRealtimeVersion = input.ReadString(ref result.gtfsRealtimeVersion_);
                                break;
                            }
                        case 16:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.incrementality_, out unknown))
                                {
                                    result.hasIncrementality = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(2, (ulong)(int)unknown);
                                }
                                break;
                            }
                        case 24:
                            {
                                result.hasTimestamp = input.ReadUInt64(ref result.timestamp_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasGtfsRealtimeVersion
            {
                get { return result.hasGtfsRealtimeVersion; }
            }
            public string GtfsRealtimeVersion
            {
                get { return result.GtfsRealtimeVersion; }
                set { SetGtfsRealtimeVersion(value); }
            }
            public Builder SetGtfsRealtimeVersion(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasGtfsRealtimeVersion = true;
                result.gtfsRealtimeVersion_ = value;
                return this;
            }
            public Builder ClearGtfsRealtimeVersion()
            {
                PrepareBuilder();
                result.hasGtfsRealtimeVersion = false;
                result.gtfsRealtimeVersion_ = "";
                return this;
            }

            public bool HasIncrementality
            {
                get { return result.hasIncrementality; }
            }
            public global::TransitRealtime.FeedHeader.Types.Incrementality Incrementality
            {
                get { return result.Incrementality; }
                set { SetIncrementality(value); }
            }
            public Builder SetIncrementality(global::TransitRealtime.FeedHeader.Types.Incrementality value)
            {
                PrepareBuilder();
                result.hasIncrementality = true;
                result.incrementality_ = value;
                return this;
            }
            public Builder ClearIncrementality()
            {
                PrepareBuilder();
                result.hasIncrementality = false;
                result.incrementality_ = global::TransitRealtime.FeedHeader.Types.Incrementality.FULL_DATASET;
                return this;
            }

            public bool HasTimestamp
            {
                get { return result.hasTimestamp; }
            }
            [global::System.CLSCompliant(false)]
            public ulong Timestamp
            {
                get { return result.Timestamp; }
                set { SetTimestamp(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetTimestamp(ulong value)
            {
                PrepareBuilder();
                result.hasTimestamp = true;
                result.timestamp_ = value;
                return this;
            }
            public Builder ClearTimestamp()
            {
                PrepareBuilder();
                result.hasTimestamp = false;
                result.timestamp_ = 0UL;
                return this;
            }
        }
        static FeedHeader()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class FeedEntity : pb::ExtendableMessage<FeedEntity, FeedEntity.Builder>
    {
        private FeedEntity() { }
        private static readonly FeedEntity defaultInstance = new FeedEntity().MakeReadOnly();
        private static readonly string[] _feedEntityFieldNames = new string[] { "alert", "id", "is_deleted", "trip_update", "vehicle" };
        private static readonly uint[] _feedEntityFieldTags = new uint[] { 42, 10, 16, 26, 34 };
        public static FeedEntity DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override FeedEntity DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override FeedEntity ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_FeedEntity__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<FeedEntity, FeedEntity.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_FeedEntity__FieldAccessorTable; }
        }

        public const int IdFieldNumber = 1;
        private bool hasId;
        private string id_ = "";
        public bool HasId
        {
            get { return hasId; }
        }
        public string Id
        {
            get { return id_; }
        }

        public const int IsDeletedFieldNumber = 2;
        private bool hasIsDeleted;
        private bool isDeleted_;
        public bool HasIsDeleted
        {
            get { return hasIsDeleted; }
        }
        public bool IsDeleted
        {
            get { return isDeleted_; }
        }

        public const int TripUpdateFieldNumber = 3;
        private bool hasTripUpdate;
        private global::TransitRealtime.TripUpdate tripUpdate_;
        public bool HasTripUpdate
        {
            get { return hasTripUpdate; }
        }
        public global::TransitRealtime.TripUpdate TripUpdate
        {
            get { return tripUpdate_ ?? global::TransitRealtime.TripUpdate.DefaultInstance; }
        }

        public const int VehicleFieldNumber = 4;
        private bool hasVehicle;
        private global::TransitRealtime.VehiclePosition vehicle_;
        public bool HasVehicle
        {
            get { return hasVehicle; }
        }
        public global::TransitRealtime.VehiclePosition Vehicle
        {
            get { return vehicle_ ?? global::TransitRealtime.VehiclePosition.DefaultInstance; }
        }

        public const int AlertFieldNumber = 5;
        private bool hasAlert;
        private global::TransitRealtime.Alert alert_;
        public bool HasAlert
        {
            get { return hasAlert; }
        }
        public global::TransitRealtime.Alert Alert
        {
            get { return alert_ ?? global::TransitRealtime.Alert.DefaultInstance; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasId) return false;
                if (HasTripUpdate)
                {
                    if (!TripUpdate.IsInitialized) return false;
                }
                if (HasVehicle)
                {
                    if (!Vehicle.IsInitialized) return false;
                }
                if (HasAlert)
                {
                    if (!Alert.IsInitialized) return false;
                }
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _feedEntityFieldNames;
            pb::ExtendableMessage<FeedEntity, FeedEntity.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasId)
            {
                output.WriteString(1, field_names[1], Id);
            }
            if (hasIsDeleted)
            {
                output.WriteBool(2, field_names[2], IsDeleted);
            }
            if (hasTripUpdate)
            {
                output.WriteMessage(3, field_names[3], TripUpdate);
            }
            if (hasVehicle)
            {
                output.WriteMessage(4, field_names[4], Vehicle);
            }
            if (hasAlert)
            {
                output.WriteMessage(5, field_names[0], Alert);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(1, Id);
            }
            if (hasIsDeleted)
            {
                size += pb::CodedOutputStream.ComputeBoolSize(2, IsDeleted);
            }
            if (hasTripUpdate)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(3, TripUpdate);
            }
            if (hasVehicle)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(4, Vehicle);
            }
            if (hasAlert)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(5, Alert);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static FeedEntity ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static FeedEntity ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static FeedEntity ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static FeedEntity ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static FeedEntity ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static FeedEntity ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static FeedEntity ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static FeedEntity ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static FeedEntity ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static FeedEntity ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private FeedEntity MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(FeedEntity prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<FeedEntity, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(FeedEntity cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private FeedEntity result;

            private FeedEntity PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    FeedEntity original = result;
                    result = new FeedEntity();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override FeedEntity MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.FeedEntity.Descriptor; }
            }

            public override FeedEntity DefaultInstanceForType
            {
                get { return global::TransitRealtime.FeedEntity.DefaultInstance; }
            }

            public override FeedEntity BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is FeedEntity)
                {
                    return MergeFrom((FeedEntity)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(FeedEntity other)
            {
                if (other == global::TransitRealtime.FeedEntity.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasId)
                {
                    Id = other.Id;
                }
                if (other.HasIsDeleted)
                {
                    IsDeleted = other.IsDeleted;
                }
                if (other.HasTripUpdate)
                {
                    MergeTripUpdate(other.TripUpdate);
                }
                if (other.HasVehicle)
                {
                    MergeVehicle(other.Vehicle);
                }
                if (other.HasAlert)
                {
                    MergeAlert(other.Alert);
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_feedEntityFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _feedEntityFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                result.hasId = input.ReadString(ref result.id_);
                                break;
                            }
                        case 16:
                            {
                                result.hasIsDeleted = input.ReadBool(ref result.isDeleted_);
                                break;
                            }
                        case 26:
                            {
                                global::TransitRealtime.TripUpdate.Builder subBuilder = global::TransitRealtime.TripUpdate.CreateBuilder();
                                if (result.hasTripUpdate)
                                {
                                    subBuilder.MergeFrom(TripUpdate);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                TripUpdate = subBuilder.BuildPartial();
                                break;
                            }
                        case 34:
                            {
                                global::TransitRealtime.VehiclePosition.Builder subBuilder = global::TransitRealtime.VehiclePosition.CreateBuilder();
                                if (result.hasVehicle)
                                {
                                    subBuilder.MergeFrom(Vehicle);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Vehicle = subBuilder.BuildPartial();
                                break;
                            }
                        case 42:
                            {
                                global::TransitRealtime.Alert.Builder subBuilder = global::TransitRealtime.Alert.CreateBuilder();
                                if (result.hasAlert)
                                {
                                    subBuilder.MergeFrom(Alert);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Alert = subBuilder.BuildPartial();
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasId
            {
                get { return result.hasId; }
            }
            public string Id
            {
                get { return result.Id; }
                set { SetId(value); }
            }
            public Builder SetId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasId = true;
                result.id_ = value;
                return this;
            }
            public Builder ClearId()
            {
                PrepareBuilder();
                result.hasId = false;
                result.id_ = "";
                return this;
            }

            public bool HasIsDeleted
            {
                get { return result.hasIsDeleted; }
            }
            public bool IsDeleted
            {
                get { return result.IsDeleted; }
                set { SetIsDeleted(value); }
            }
            public Builder SetIsDeleted(bool value)
            {
                PrepareBuilder();
                result.hasIsDeleted = true;
                result.isDeleted_ = value;
                return this;
            }
            public Builder ClearIsDeleted()
            {
                PrepareBuilder();
                result.hasIsDeleted = false;
                result.isDeleted_ = false;
                return this;
            }

            public bool HasTripUpdate
            {
                get { return result.hasTripUpdate; }
            }
            public global::TransitRealtime.TripUpdate TripUpdate
            {
                get { return result.TripUpdate; }
                set { SetTripUpdate(value); }
            }
            public Builder SetTripUpdate(global::TransitRealtime.TripUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTripUpdate = true;
                result.tripUpdate_ = value;
                return this;
            }
            public Builder SetTripUpdate(global::TransitRealtime.TripUpdate.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTripUpdate = true;
                result.tripUpdate_ = builderForValue.Build();
                return this;
            }
            public Builder MergeTripUpdate(global::TransitRealtime.TripUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTripUpdate &&
                    result.tripUpdate_ != global::TransitRealtime.TripUpdate.DefaultInstance)
                {
                    result.tripUpdate_ = global::TransitRealtime.TripUpdate.CreateBuilder(result.tripUpdate_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.tripUpdate_ = value;
                }
                result.hasTripUpdate = true;
                return this;
            }
            public Builder ClearTripUpdate()
            {
                PrepareBuilder();
                result.hasTripUpdate = false;
                result.tripUpdate_ = null;
                return this;
            }

            public bool HasVehicle
            {
                get { return result.hasVehicle; }
            }
            public global::TransitRealtime.VehiclePosition Vehicle
            {
                get { return result.Vehicle; }
                set { SetVehicle(value); }
            }
            public Builder SetVehicle(global::TransitRealtime.VehiclePosition value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = value;
                return this;
            }
            public Builder SetVehicle(global::TransitRealtime.VehiclePosition.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = builderForValue.Build();
                return this;
            }
            public Builder MergeVehicle(global::TransitRealtime.VehiclePosition value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasVehicle &&
                    result.vehicle_ != global::TransitRealtime.VehiclePosition.DefaultInstance)
                {
                    result.vehicle_ = global::TransitRealtime.VehiclePosition.CreateBuilder(result.vehicle_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.vehicle_ = value;
                }
                result.hasVehicle = true;
                return this;
            }
            public Builder ClearVehicle()
            {
                PrepareBuilder();
                result.hasVehicle = false;
                result.vehicle_ = null;
                return this;
            }

            public bool HasAlert
            {
                get { return result.hasAlert; }
            }
            public global::TransitRealtime.Alert Alert
            {
                get { return result.Alert; }
                set { SetAlert(value); }
            }
            public Builder SetAlert(global::TransitRealtime.Alert value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasAlert = true;
                result.alert_ = value;
                return this;
            }
            public Builder SetAlert(global::TransitRealtime.Alert.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasAlert = true;
                result.alert_ = builderForValue.Build();
                return this;
            }
            public Builder MergeAlert(global::TransitRealtime.Alert value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasAlert &&
                    result.alert_ != global::TransitRealtime.Alert.DefaultInstance)
                {
                    result.alert_ = global::TransitRealtime.Alert.CreateBuilder(result.alert_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.alert_ = value;
                }
                result.hasAlert = true;
                return this;
            }
            public Builder ClearAlert()
            {
                PrepareBuilder();
                result.hasAlert = false;
                result.alert_ = null;
                return this;
            }
        }
        static FeedEntity()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TripUpdate : pb::ExtendableMessage<TripUpdate, TripUpdate.Builder>
    {
        private TripUpdate() { }
        private static readonly TripUpdate defaultInstance = new TripUpdate().MakeReadOnly();
        private static readonly string[] _tripUpdateFieldNames = new string[] { "delay", "stop_time_update", "timestamp", "trip", "vehicle" };
        private static readonly uint[] _tripUpdateFieldTags = new uint[] { 40, 18, 32, 10, 26 };
        public static TripUpdate DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TripUpdate DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TripUpdate ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripUpdate__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TripUpdate, TripUpdate.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripUpdate__FieldAccessorTable; }
        }

        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class StopTimeEvent : pb::ExtendableMessage<StopTimeEvent, StopTimeEvent.Builder>
            {
                private StopTimeEvent() { }
                private static readonly StopTimeEvent defaultInstance = new StopTimeEvent().MakeReadOnly();
                private static readonly string[] _stopTimeEventFieldNames = new string[] { "delay", "time", "uncertainty" };
                private static readonly uint[] _stopTimeEventFieldTags = new uint[] { 8, 16, 24 };
                public static StopTimeEvent DefaultInstance
                {
                    get { return defaultInstance; }
                }

                public override StopTimeEvent DefaultInstanceForType
                {
                    get { return DefaultInstance; }
                }

                protected override StopTimeEvent ThisMessage
                {
                    get { return this; }
                }

                public static pbd::MessageDescriptor Descriptor
                {
                    get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripUpdate_StopTimeEvent__Descriptor; }
                }

                protected override pb::FieldAccess.FieldAccessorTable<StopTimeEvent, StopTimeEvent.Builder> InternalFieldAccessors
                {
                    get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripUpdate_StopTimeEvent__FieldAccessorTable; }
                }

                public const int DelayFieldNumber = 1;
                private bool hasDelay;
                private int delay_;
                public bool HasDelay
                {
                    get { return hasDelay; }
                }
                public int Delay
                {
                    get { return delay_; }
                }

                public const int TimeFieldNumber = 2;
                private bool hasTime;
                private long time_;
                public bool HasTime
                {
                    get { return hasTime; }
                }
                public long Time
                {
                    get { return time_; }
                }

                public const int UncertaintyFieldNumber = 3;
                private bool hasUncertainty;
                private int uncertainty_;
                public bool HasUncertainty
                {
                    get { return hasUncertainty; }
                }
                public int Uncertainty
                {
                    get { return uncertainty_; }
                }

                public override bool IsInitialized
                {
                    get
                    {
                        if (!ExtensionsAreInitialized) return false;
                        return true;
                    }
                }

                public override void WriteTo(pb::ICodedOutputStream output)
                {
                    CalcSerializedSize();
                    string[] field_names = _stopTimeEventFieldNames;
                    pb::ExtendableMessage<StopTimeEvent, StopTimeEvent.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
                    if (hasDelay)
                    {
                        output.WriteInt32(1, field_names[0], Delay);
                    }
                    if (hasTime)
                    {
                        output.WriteInt64(2, field_names[1], Time);
                    }
                    if (hasUncertainty)
                    {
                        output.WriteInt32(3, field_names[2], Uncertainty);
                    }
                    extensionWriter.WriteUntil(2000, output);
                    UnknownFields.WriteTo(output);
                }

                private int memoizedSerializedSize = -1;
                public override int SerializedSize
                {
                    get
                    {
                        int size = memoizedSerializedSize;
                        if (size != -1) return size;
                        return CalcSerializedSize();
                    }
                }

                private int CalcSerializedSize()
                {
                    int size = memoizedSerializedSize;
                    if (size != -1) return size;

                    size = 0;
                    if (hasDelay)
                    {
                        size += pb::CodedOutputStream.ComputeInt32Size(1, Delay);
                    }
                    if (hasTime)
                    {
                        size += pb::CodedOutputStream.ComputeInt64Size(2, Time);
                    }
                    if (hasUncertainty)
                    {
                        size += pb::CodedOutputStream.ComputeInt32Size(3, Uncertainty);
                    }
                    size += ExtensionsSerializedSize;
                    size += UnknownFields.SerializedSize;
                    memoizedSerializedSize = size;
                    return size;
                }
                public static StopTimeEvent ParseFrom(pb::ByteString data)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(byte[] data)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(global::System.IO.Stream input)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }
                public static StopTimeEvent ParseDelimitedFrom(global::System.IO.Stream input)
                {
                    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
                }
                public static StopTimeEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(pb::ICodedInputStream input)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
                }
                public static StopTimeEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }
                private StopTimeEvent MakeReadOnly()
                {
                    return this;
                }

                public static Builder CreateBuilder() { return new Builder(); }
                public override Builder ToBuilder() { return CreateBuilder(this); }
                public override Builder CreateBuilderForType() { return new Builder(); }
                public static Builder CreateBuilder(StopTimeEvent prototype)
                {
                    return new Builder(prototype);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public sealed partial class Builder : pb::ExtendableBuilder<StopTimeEvent, Builder>
                {
                    protected override Builder ThisBuilder
                    {
                        get { return this; }
                    }
                    public Builder()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                    }
                    internal Builder(StopTimeEvent cloneFrom)
                    {
                        result = cloneFrom;
                        resultIsReadOnly = true;
                    }

                    private bool resultIsReadOnly;
                    private StopTimeEvent result;

                    private StopTimeEvent PrepareBuilder()
                    {
                        if (resultIsReadOnly)
                        {
                            StopTimeEvent original = result;
                            result = new StopTimeEvent();
                            resultIsReadOnly = false;
                            MergeFrom(original);
                        }
                        return result;
                    }

                    public override bool IsInitialized
                    {
                        get { return result.IsInitialized; }
                    }

                    protected override StopTimeEvent MessageBeingBuilt
                    {
                        get { return PrepareBuilder(); }
                    }

                    public override Builder Clear()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                        return this;
                    }

                    public override Builder Clone()
                    {
                        if (resultIsReadOnly)
                        {
                            return new Builder(result);
                        }
                        else
                        {
                            return new Builder().MergeFrom(result);
                        }
                    }

                    public override pbd::MessageDescriptor DescriptorForType
                    {
                        get { return global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Descriptor; }
                    }

                    public override StopTimeEvent DefaultInstanceForType
                    {
                        get { return global::TransitRealtime.TripUpdate.Types.StopTimeEvent.DefaultInstance; }
                    }

                    public override StopTimeEvent BuildPartial()
                    {
                        if (resultIsReadOnly)
                        {
                            return result;
                        }
                        resultIsReadOnly = true;
                        return result.MakeReadOnly();
                    }

                    public override Builder MergeFrom(pb::IMessage other)
                    {
                        if (other is StopTimeEvent)
                        {
                            return MergeFrom((StopTimeEvent)other);
                        }
                        else
                        {
                            base.MergeFrom(other);
                            return this;
                        }
                    }

                    public override Builder MergeFrom(StopTimeEvent other)
                    {
                        if (other == global::TransitRealtime.TripUpdate.Types.StopTimeEvent.DefaultInstance) return this;
                        PrepareBuilder();
                        if (other.HasDelay)
                        {
                            Delay = other.Delay;
                        }
                        if (other.HasTime)
                        {
                            Time = other.Time;
                        }
                        if (other.HasUncertainty)
                        {
                            Uncertainty = other.Uncertainty;
                        }
                        this.MergeExtensionFields(other);
                        this.MergeUnknownFields(other.UnknownFields);
                        return this;
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input)
                    {
                        return MergeFrom(input, pb::ExtensionRegistry.Empty);
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                    {
                        PrepareBuilder();
                        pb::UnknownFieldSet.Builder unknownFields = null;
                        uint tag;
                        string field_name;
                        while (input.ReadTag(out tag, out field_name))
                        {
                            if (tag == 0 && field_name != null)
                            {
                                int field_ordinal = global::System.Array.BinarySearch(_stopTimeEventFieldNames, field_name, global::System.StringComparer.Ordinal);
                                if (field_ordinal >= 0)
                                    tag = _stopTimeEventFieldTags[field_ordinal];
                                else
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    continue;
                                }
                            }
                            switch (tag)
                            {
                                case 0:
                                    {
                                        throw pb::InvalidProtocolBufferException.InvalidTag();
                                    }
                                default:
                                    {
                                        if (pb::WireFormat.IsEndGroupTag(tag))
                                        {
                                            if (unknownFields != null)
                                            {
                                                this.UnknownFields = unknownFields.Build();
                                            }
                                            return this;
                                        }
                                        if (unknownFields == null)
                                        {
                                            unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                        }
                                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                        break;
                                    }
                                case 8:
                                    {
                                        result.hasDelay = input.ReadInt32(ref result.delay_);
                                        break;
                                    }
                                case 16:
                                    {
                                        result.hasTime = input.ReadInt64(ref result.time_);
                                        break;
                                    }
                                case 24:
                                    {
                                        result.hasUncertainty = input.ReadInt32(ref result.uncertainty_);
                                        break;
                                    }
                            }
                        }

                        if (unknownFields != null)
                        {
                            this.UnknownFields = unknownFields.Build();
                        }
                        return this;
                    }


                    public bool HasDelay
                    {
                        get { return result.hasDelay; }
                    }
                    public int Delay
                    {
                        get { return result.Delay; }
                        set { SetDelay(value); }
                    }
                    public Builder SetDelay(int value)
                    {
                        PrepareBuilder();
                        result.hasDelay = true;
                        result.delay_ = value;
                        return this;
                    }
                    public Builder ClearDelay()
                    {
                        PrepareBuilder();
                        result.hasDelay = false;
                        result.delay_ = 0;
                        return this;
                    }

                    public bool HasTime
                    {
                        get { return result.hasTime; }
                    }
                    public long Time
                    {
                        get { return result.Time; }
                        set { SetTime(value); }
                    }
                    public Builder SetTime(long value)
                    {
                        PrepareBuilder();
                        result.hasTime = true;
                        result.time_ = value;
                        return this;
                    }
                    public Builder ClearTime()
                    {
                        PrepareBuilder();
                        result.hasTime = false;
                        result.time_ = 0L;
                        return this;
                    }

                    public bool HasUncertainty
                    {
                        get { return result.hasUncertainty; }
                    }
                    public int Uncertainty
                    {
                        get { return result.Uncertainty; }
                        set { SetUncertainty(value); }
                    }
                    public Builder SetUncertainty(int value)
                    {
                        PrepareBuilder();
                        result.hasUncertainty = true;
                        result.uncertainty_ = value;
                        return this;
                    }
                    public Builder ClearUncertainty()
                    {
                        PrepareBuilder();
                        result.hasUncertainty = false;
                        result.uncertainty_ = 0;
                        return this;
                    }
                }
                static StopTimeEvent()
                {
                    object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
                }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class StopTimeUpdate : pb::ExtendableMessage<StopTimeUpdate, StopTimeUpdate.Builder>
            {
                private StopTimeUpdate() { }
                private static readonly StopTimeUpdate defaultInstance = new StopTimeUpdate().MakeReadOnly();
                private static readonly string[] _stopTimeUpdateFieldNames = new string[] { "arrival", "departure", "schedule_relationship", "stop_id", "stop_sequence" };
                private static readonly uint[] _stopTimeUpdateFieldTags = new uint[] { 18, 26, 40, 34, 8 };
                public static StopTimeUpdate DefaultInstance
                {
                    get { return defaultInstance; }
                }

                public override StopTimeUpdate DefaultInstanceForType
                {
                    get { return DefaultInstance; }
                }

                protected override StopTimeUpdate ThisMessage
                {
                    get { return this; }
                }

                public static pbd::MessageDescriptor Descriptor
                {
                    get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripUpdate_StopTimeUpdate__Descriptor; }
                }

                protected override pb::FieldAccess.FieldAccessorTable<StopTimeUpdate, StopTimeUpdate.Builder> InternalFieldAccessors
                {
                    get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripUpdate_StopTimeUpdate__FieldAccessorTable; }
                }

                #region Nested types
                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public static partial class Types
                {
                    public enum ScheduleRelationship
                    {
                        SCHEDULED = 0,
                        SKIPPED = 1,
                        NO_DATA = 2,
                    }

                }
                #endregion

                public const int StopSequenceFieldNumber = 1;
                private bool hasStopSequence;
                private uint stopSequence_;
                public bool HasStopSequence
                {
                    get { return hasStopSequence; }
                }
                [global::System.CLSCompliant(false)]
                public uint StopSequence
                {
                    get { return stopSequence_; }
                }

                public const int StopIdFieldNumber = 4;
                private bool hasStopId;
                private string stopId_ = "";
                public bool HasStopId
                {
                    get { return hasStopId; }
                }
                public string StopId
                {
                    get { return stopId_; }
                }

                public const int ArrivalFieldNumber = 2;
                private bool hasArrival;
                private global::TransitRealtime.TripUpdate.Types.StopTimeEvent arrival_;
                public bool HasArrival
                {
                    get { return hasArrival; }
                }
                public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Arrival
                {
                    get { return arrival_ ?? global::TransitRealtime.TripUpdate.Types.StopTimeEvent.DefaultInstance; }
                }

                public const int DepartureFieldNumber = 3;
                private bool hasDeparture;
                private global::TransitRealtime.TripUpdate.Types.StopTimeEvent departure_;
                public bool HasDeparture
                {
                    get { return hasDeparture; }
                }
                public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Departure
                {
                    get { return departure_ ?? global::TransitRealtime.TripUpdate.Types.StopTimeEvent.DefaultInstance; }
                }

                public const int ScheduleRelationshipFieldNumber = 5;
                private bool hasScheduleRelationship;
                private global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship scheduleRelationship_ = global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship.SCHEDULED;
                public bool HasScheduleRelationship
                {
                    get { return hasScheduleRelationship; }
                }
                public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationship
                {
                    get { return scheduleRelationship_; }
                }

                public override bool IsInitialized
                {
                    get
                    {
                        if (!ExtensionsAreInitialized) return false;
                        return true;
                    }
                }

                public override void WriteTo(pb::ICodedOutputStream output)
                {
                    CalcSerializedSize();
                    string[] field_names = _stopTimeUpdateFieldNames;
                    pb::ExtendableMessage<StopTimeUpdate, StopTimeUpdate.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
                    if (hasStopSequence)
                    {
                        output.WriteUInt32(1, field_names[4], StopSequence);
                    }
                    if (hasArrival)
                    {
                        output.WriteMessage(2, field_names[0], Arrival);
                    }
                    if (hasDeparture)
                    {
                        output.WriteMessage(3, field_names[1], Departure);
                    }
                    if (hasStopId)
                    {
                        output.WriteString(4, field_names[3], StopId);
                    }
                    if (hasScheduleRelationship)
                    {
                        output.WriteEnum(5, field_names[2], (int)ScheduleRelationship, ScheduleRelationship);
                    }
                    extensionWriter.WriteUntil(2000, output);
                    UnknownFields.WriteTo(output);
                }

                private int memoizedSerializedSize = -1;
                public override int SerializedSize
                {
                    get
                    {
                        int size = memoizedSerializedSize;
                        if (size != -1) return size;
                        return CalcSerializedSize();
                    }
                }

                private int CalcSerializedSize()
                {
                    int size = memoizedSerializedSize;
                    if (size != -1) return size;

                    size = 0;
                    if (hasStopSequence)
                    {
                        size += pb::CodedOutputStream.ComputeUInt32Size(1, StopSequence);
                    }
                    if (hasStopId)
                    {
                        size += pb::CodedOutputStream.ComputeStringSize(4, StopId);
                    }
                    if (hasArrival)
                    {
                        size += pb::CodedOutputStream.ComputeMessageSize(2, Arrival);
                    }
                    if (hasDeparture)
                    {
                        size += pb::CodedOutputStream.ComputeMessageSize(3, Departure);
                    }
                    if (hasScheduleRelationship)
                    {
                        size += pb::CodedOutputStream.ComputeEnumSize(5, (int)ScheduleRelationship);
                    }
                    size += ExtensionsSerializedSize;
                    size += UnknownFields.SerializedSize;
                    memoizedSerializedSize = size;
                    return size;
                }
                public static StopTimeUpdate ParseFrom(pb::ByteString data)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(byte[] data)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(global::System.IO.Stream input)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }
                public static StopTimeUpdate ParseDelimitedFrom(global::System.IO.Stream input)
                {
                    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
                }
                public static StopTimeUpdate ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(pb::ICodedInputStream input)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
                }
                public static StopTimeUpdate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }
                private StopTimeUpdate MakeReadOnly()
                {
                    return this;
                }

                public static Builder CreateBuilder() { return new Builder(); }
                public override Builder ToBuilder() { return CreateBuilder(this); }
                public override Builder CreateBuilderForType() { return new Builder(); }
                public static Builder CreateBuilder(StopTimeUpdate prototype)
                {
                    return new Builder(prototype);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public sealed partial class Builder : pb::ExtendableBuilder<StopTimeUpdate, Builder>
                {
                    protected override Builder ThisBuilder
                    {
                        get { return this; }
                    }
                    public Builder()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                    }
                    internal Builder(StopTimeUpdate cloneFrom)
                    {
                        result = cloneFrom;
                        resultIsReadOnly = true;
                    }

                    private bool resultIsReadOnly;
                    private StopTimeUpdate result;

                    private StopTimeUpdate PrepareBuilder()
                    {
                        if (resultIsReadOnly)
                        {
                            StopTimeUpdate original = result;
                            result = new StopTimeUpdate();
                            resultIsReadOnly = false;
                            MergeFrom(original);
                        }
                        return result;
                    }

                    public override bool IsInitialized
                    {
                        get { return result.IsInitialized; }
                    }

                    protected override StopTimeUpdate MessageBeingBuilt
                    {
                        get { return PrepareBuilder(); }
                    }

                    public override Builder Clear()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                        return this;
                    }

                    public override Builder Clone()
                    {
                        if (resultIsReadOnly)
                        {
                            return new Builder(result);
                        }
                        else
                        {
                            return new Builder().MergeFrom(result);
                        }
                    }

                    public override pbd::MessageDescriptor DescriptorForType
                    {
                        get { return global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Descriptor; }
                    }

                    public override StopTimeUpdate DefaultInstanceForType
                    {
                        get { return global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.DefaultInstance; }
                    }

                    public override StopTimeUpdate BuildPartial()
                    {
                        if (resultIsReadOnly)
                        {
                            return result;
                        }
                        resultIsReadOnly = true;
                        return result.MakeReadOnly();
                    }

                    public override Builder MergeFrom(pb::IMessage other)
                    {
                        if (other is StopTimeUpdate)
                        {
                            return MergeFrom((StopTimeUpdate)other);
                        }
                        else
                        {
                            base.MergeFrom(other);
                            return this;
                        }
                    }

                    public override Builder MergeFrom(StopTimeUpdate other)
                    {
                        if (other == global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.DefaultInstance) return this;
                        PrepareBuilder();
                        if (other.HasStopSequence)
                        {
                            StopSequence = other.StopSequence;
                        }
                        if (other.HasStopId)
                        {
                            StopId = other.StopId;
                        }
                        if (other.HasArrival)
                        {
                            MergeArrival(other.Arrival);
                        }
                        if (other.HasDeparture)
                        {
                            MergeDeparture(other.Departure);
                        }
                        if (other.HasScheduleRelationship)
                        {
                            ScheduleRelationship = other.ScheduleRelationship;
                        }
                        this.MergeExtensionFields(other);
                        this.MergeUnknownFields(other.UnknownFields);
                        return this;
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input)
                    {
                        return MergeFrom(input, pb::ExtensionRegistry.Empty);
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                    {
                        PrepareBuilder();
                        pb::UnknownFieldSet.Builder unknownFields = null;
                        uint tag;
                        string field_name;
                        while (input.ReadTag(out tag, out field_name))
                        {
                            if (tag == 0 && field_name != null)
                            {
                                int field_ordinal = global::System.Array.BinarySearch(_stopTimeUpdateFieldNames, field_name, global::System.StringComparer.Ordinal);
                                if (field_ordinal >= 0)
                                    tag = _stopTimeUpdateFieldTags[field_ordinal];
                                else
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    continue;
                                }
                            }
                            switch (tag)
                            {
                                case 0:
                                    {
                                        throw pb::InvalidProtocolBufferException.InvalidTag();
                                    }
                                default:
                                    {
                                        if (pb::WireFormat.IsEndGroupTag(tag))
                                        {
                                            if (unknownFields != null)
                                            {
                                                this.UnknownFields = unknownFields.Build();
                                            }
                                            return this;
                                        }
                                        if (unknownFields == null)
                                        {
                                            unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                        }
                                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                        break;
                                    }
                                case 8:
                                    {
                                        result.hasStopSequence = input.ReadUInt32(ref result.stopSequence_);
                                        break;
                                    }
                                case 18:
                                    {
                                        global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Builder subBuilder = global::TransitRealtime.TripUpdate.Types.StopTimeEvent.CreateBuilder();
                                        if (result.hasArrival)
                                        {
                                            subBuilder.MergeFrom(Arrival);
                                        }
                                        input.ReadMessage(subBuilder, extensionRegistry);
                                        Arrival = subBuilder.BuildPartial();
                                        break;
                                    }
                                case 26:
                                    {
                                        global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Builder subBuilder = global::TransitRealtime.TripUpdate.Types.StopTimeEvent.CreateBuilder();
                                        if (result.hasDeparture)
                                        {
                                            subBuilder.MergeFrom(Departure);
                                        }
                                        input.ReadMessage(subBuilder, extensionRegistry);
                                        Departure = subBuilder.BuildPartial();
                                        break;
                                    }
                                case 34:
                                    {
                                        result.hasStopId = input.ReadString(ref result.stopId_);
                                        break;
                                    }
                                case 40:
                                    {
                                        object unknown;
                                        if (input.ReadEnum(ref result.scheduleRelationship_, out unknown))
                                        {
                                            result.hasScheduleRelationship = true;
                                        }
                                        else if (unknown is int)
                                        {
                                            if (unknownFields == null)
                                            {
                                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                            }
                                            unknownFields.MergeVarintField(5, (ulong)(int)unknown);
                                        }
                                        break;
                                    }
                            }
                        }

                        if (unknownFields != null)
                        {
                            this.UnknownFields = unknownFields.Build();
                        }
                        return this;
                    }


                    public bool HasStopSequence
                    {
                        get { return result.hasStopSequence; }
                    }
                    [global::System.CLSCompliant(false)]
                    public uint StopSequence
                    {
                        get { return result.StopSequence; }
                        set { SetStopSequence(value); }
                    }
                    [global::System.CLSCompliant(false)]
                    public Builder SetStopSequence(uint value)
                    {
                        PrepareBuilder();
                        result.hasStopSequence = true;
                        result.stopSequence_ = value;
                        return this;
                    }
                    public Builder ClearStopSequence()
                    {
                        PrepareBuilder();
                        result.hasStopSequence = false;
                        result.stopSequence_ = 0;
                        return this;
                    }

                    public bool HasStopId
                    {
                        get { return result.hasStopId; }
                    }
                    public string StopId
                    {
                        get { return result.StopId; }
                        set { SetStopId(value); }
                    }
                    public Builder SetStopId(string value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasStopId = true;
                        result.stopId_ = value;
                        return this;
                    }
                    public Builder ClearStopId()
                    {
                        PrepareBuilder();
                        result.hasStopId = false;
                        result.stopId_ = "";
                        return this;
                    }

                    public bool HasArrival
                    {
                        get { return result.hasArrival; }
                    }
                    public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Arrival
                    {
                        get { return result.Arrival; }
                        set { SetArrival(value); }
                    }
                    public Builder SetArrival(global::TransitRealtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasArrival = true;
                        result.arrival_ = value;
                        return this;
                    }
                    public Builder SetArrival(global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Builder builderForValue)
                    {
                        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                        PrepareBuilder();
                        result.hasArrival = true;
                        result.arrival_ = builderForValue.Build();
                        return this;
                    }
                    public Builder MergeArrival(global::TransitRealtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        if (result.hasArrival &&
                            result.arrival_ != global::TransitRealtime.TripUpdate.Types.StopTimeEvent.DefaultInstance)
                        {
                            result.arrival_ = global::TransitRealtime.TripUpdate.Types.StopTimeEvent.CreateBuilder(result.arrival_).MergeFrom(value).BuildPartial();
                        }
                        else
                        {
                            result.arrival_ = value;
                        }
                        result.hasArrival = true;
                        return this;
                    }
                    public Builder ClearArrival()
                    {
                        PrepareBuilder();
                        result.hasArrival = false;
                        result.arrival_ = null;
                        return this;
                    }

                    public bool HasDeparture
                    {
                        get { return result.hasDeparture; }
                    }
                    public global::TransitRealtime.TripUpdate.Types.StopTimeEvent Departure
                    {
                        get { return result.Departure; }
                        set { SetDeparture(value); }
                    }
                    public Builder SetDeparture(global::TransitRealtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasDeparture = true;
                        result.departure_ = value;
                        return this;
                    }
                    public Builder SetDeparture(global::TransitRealtime.TripUpdate.Types.StopTimeEvent.Builder builderForValue)
                    {
                        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                        PrepareBuilder();
                        result.hasDeparture = true;
                        result.departure_ = builderForValue.Build();
                        return this;
                    }
                    public Builder MergeDeparture(global::TransitRealtime.TripUpdate.Types.StopTimeEvent value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        if (result.hasDeparture &&
                            result.departure_ != global::TransitRealtime.TripUpdate.Types.StopTimeEvent.DefaultInstance)
                        {
                            result.departure_ = global::TransitRealtime.TripUpdate.Types.StopTimeEvent.CreateBuilder(result.departure_).MergeFrom(value).BuildPartial();
                        }
                        else
                        {
                            result.departure_ = value;
                        }
                        result.hasDeparture = true;
                        return this;
                    }
                    public Builder ClearDeparture()
                    {
                        PrepareBuilder();
                        result.hasDeparture = false;
                        result.departure_ = null;
                        return this;
                    }

                    public bool HasScheduleRelationship
                    {
                        get { return result.hasScheduleRelationship; }
                    }
                    public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship ScheduleRelationship
                    {
                        get { return result.ScheduleRelationship; }
                        set { SetScheduleRelationship(value); }
                    }
                    public Builder SetScheduleRelationship(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship value)
                    {
                        PrepareBuilder();
                        result.hasScheduleRelationship = true;
                        result.scheduleRelationship_ = value;
                        return this;
                    }
                    public Builder ClearScheduleRelationship()
                    {
                        PrepareBuilder();
                        result.hasScheduleRelationship = false;
                        result.scheduleRelationship_ = global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Types.ScheduleRelationship.SCHEDULED;
                        return this;
                    }
                }
                static StopTimeUpdate()
                {
                    object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
                }
            }

        }
        #endregion

        public const int TripFieldNumber = 1;
        private bool hasTrip;
        private global::TransitRealtime.TripDescriptor trip_;
        public bool HasTrip
        {
            get { return hasTrip; }
        }
        public global::TransitRealtime.TripDescriptor Trip
        {
            get { return trip_ ?? global::TransitRealtime.TripDescriptor.DefaultInstance; }
        }

        public const int VehicleFieldNumber = 3;
        private bool hasVehicle;
        private global::TransitRealtime.VehicleDescriptor vehicle_;
        public bool HasVehicle
        {
            get { return hasVehicle; }
        }
        public global::TransitRealtime.VehicleDescriptor Vehicle
        {
            get { return vehicle_ ?? global::TransitRealtime.VehicleDescriptor.DefaultInstance; }
        }

        public const int StopTimeUpdateFieldNumber = 2;
        private pbc::PopsicleList<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> stopTimeUpdate_ = new pbc::PopsicleList<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate>();
        public scg::IList<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> StopTimeUpdateList
        {
            get { return stopTimeUpdate_; }
        }
        public int StopTimeUpdateCount
        {
            get { return stopTimeUpdate_.Count; }
        }
        public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate GetStopTimeUpdate(int index)
        {
            return stopTimeUpdate_[index];
        }

        public const int TimestampFieldNumber = 4;
        private bool hasTimestamp;
        private ulong timestamp_;
        public bool HasTimestamp
        {
            get { return hasTimestamp; }
        }
        [global::System.CLSCompliant(false)]
        public ulong Timestamp
        {
            get { return timestamp_; }
        }

        public const int DelayFieldNumber = 5;
        private bool hasDelay;
        private int delay_;
        public bool HasDelay
        {
            get { return hasDelay; }
        }
        public int Delay
        {
            get { return delay_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasTrip) return false;
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _tripUpdateFieldNames;
            pb::ExtendableMessage<TripUpdate, TripUpdate.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasTrip)
            {
                output.WriteMessage(1, field_names[3], Trip);
            }
            if (stopTimeUpdate_.Count > 0)
            {
                output.WriteMessageArray(2, field_names[1], stopTimeUpdate_);
            }
            if (hasVehicle)
            {
                output.WriteMessage(3, field_names[4], Vehicle);
            }
            if (hasTimestamp)
            {
                output.WriteUInt64(4, field_names[2], Timestamp);
            }
            if (hasDelay)
            {
                output.WriteInt32(5, field_names[0], Delay);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasTrip)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(1, Trip);
            }
            if (hasVehicle)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(3, Vehicle);
            }
            foreach (global::TransitRealtime.TripUpdate.Types.StopTimeUpdate element in StopTimeUpdateList)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(2, element);
            }
            if (hasTimestamp)
            {
                size += pb::CodedOutputStream.ComputeUInt64Size(4, Timestamp);
            }
            if (hasDelay)
            {
                size += pb::CodedOutputStream.ComputeInt32Size(5, Delay);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static TripUpdate ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TripUpdate ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TripUpdate ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TripUpdate ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TripUpdate ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TripUpdate ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static TripUpdate ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static TripUpdate ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static TripUpdate ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TripUpdate ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private TripUpdate MakeReadOnly()
        {
            stopTimeUpdate_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(TripUpdate prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<TripUpdate, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(TripUpdate cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private TripUpdate result;

            private TripUpdate PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    TripUpdate original = result;
                    result = new TripUpdate();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TripUpdate MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.TripUpdate.Descriptor; }
            }

            public override TripUpdate DefaultInstanceForType
            {
                get { return global::TransitRealtime.TripUpdate.DefaultInstance; }
            }

            public override TripUpdate BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TripUpdate)
                {
                    return MergeFrom((TripUpdate)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TripUpdate other)
            {
                if (other == global::TransitRealtime.TripUpdate.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasTrip)
                {
                    MergeTrip(other.Trip);
                }
                if (other.HasVehicle)
                {
                    MergeVehicle(other.Vehicle);
                }
                if (other.stopTimeUpdate_.Count != 0)
                {
                    result.stopTimeUpdate_.Add(other.stopTimeUpdate_);
                }
                if (other.HasTimestamp)
                {
                    Timestamp = other.Timestamp;
                }
                if (other.HasDelay)
                {
                    Delay = other.Delay;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_tripUpdateFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _tripUpdateFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                global::TransitRealtime.TripDescriptor.Builder subBuilder = global::TransitRealtime.TripDescriptor.CreateBuilder();
                                if (result.hasTrip)
                                {
                                    subBuilder.MergeFrom(Trip);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Trip = subBuilder.BuildPartial();
                                break;
                            }
                        case 18:
                            {
                                input.ReadMessageArray(tag, field_name, result.stopTimeUpdate_, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.DefaultInstance, extensionRegistry);
                                break;
                            }
                        case 26:
                            {
                                global::TransitRealtime.VehicleDescriptor.Builder subBuilder = global::TransitRealtime.VehicleDescriptor.CreateBuilder();
                                if (result.hasVehicle)
                                {
                                    subBuilder.MergeFrom(Vehicle);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Vehicle = subBuilder.BuildPartial();
                                break;
                            }
                        case 32:
                            {
                                result.hasTimestamp = input.ReadUInt64(ref result.timestamp_);
                                break;
                            }
                        case 40:
                            {
                                result.hasDelay = input.ReadInt32(ref result.delay_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasTrip
            {
                get { return result.hasTrip; }
            }
            public global::TransitRealtime.TripDescriptor Trip
            {
                get { return result.Trip; }
                set { SetTrip(value); }
            }
            public Builder SetTrip(global::TransitRealtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = value;
                return this;
            }
            public Builder SetTrip(global::TransitRealtime.TripDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = builderForValue.Build();
                return this;
            }
            public Builder MergeTrip(global::TransitRealtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTrip &&
                    result.trip_ != global::TransitRealtime.TripDescriptor.DefaultInstance)
                {
                    result.trip_ = global::TransitRealtime.TripDescriptor.CreateBuilder(result.trip_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.trip_ = value;
                }
                result.hasTrip = true;
                return this;
            }
            public Builder ClearTrip()
            {
                PrepareBuilder();
                result.hasTrip = false;
                result.trip_ = null;
                return this;
            }

            public bool HasVehicle
            {
                get { return result.hasVehicle; }
            }
            public global::TransitRealtime.VehicleDescriptor Vehicle
            {
                get { return result.Vehicle; }
                set { SetVehicle(value); }
            }
            public Builder SetVehicle(global::TransitRealtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = value;
                return this;
            }
            public Builder SetVehicle(global::TransitRealtime.VehicleDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = builderForValue.Build();
                return this;
            }
            public Builder MergeVehicle(global::TransitRealtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasVehicle &&
                    result.vehicle_ != global::TransitRealtime.VehicleDescriptor.DefaultInstance)
                {
                    result.vehicle_ = global::TransitRealtime.VehicleDescriptor.CreateBuilder(result.vehicle_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.vehicle_ = value;
                }
                result.hasVehicle = true;
                return this;
            }
            public Builder ClearVehicle()
            {
                PrepareBuilder();
                result.hasVehicle = false;
                result.vehicle_ = null;
                return this;
            }

            public pbc::IPopsicleList<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> StopTimeUpdateList
            {
                get { return PrepareBuilder().stopTimeUpdate_; }
            }
            public int StopTimeUpdateCount
            {
                get { return result.StopTimeUpdateCount; }
            }
            public global::TransitRealtime.TripUpdate.Types.StopTimeUpdate GetStopTimeUpdate(int index)
            {
                return result.GetStopTimeUpdate(index);
            }
            public Builder SetStopTimeUpdate(int index, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.stopTimeUpdate_[index] = value;
                return this;
            }
            public Builder SetStopTimeUpdate(int index, global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.stopTimeUpdate_[index] = builderForValue.Build();
                return this;
            }
            public Builder AddStopTimeUpdate(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.stopTimeUpdate_.Add(value);
                return this;
            }
            public Builder AddStopTimeUpdate(global::TransitRealtime.TripUpdate.Types.StopTimeUpdate.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.stopTimeUpdate_.Add(builderForValue.Build());
                return this;
            }
            public Builder AddRangeStopTimeUpdate(scg::IEnumerable<global::TransitRealtime.TripUpdate.Types.StopTimeUpdate> values)
            {
                PrepareBuilder();
                result.stopTimeUpdate_.Add(values);
                return this;
            }
            public Builder ClearStopTimeUpdate()
            {
                PrepareBuilder();
                result.stopTimeUpdate_.Clear();
                return this;
            }

            public bool HasTimestamp
            {
                get { return result.hasTimestamp; }
            }
            [global::System.CLSCompliant(false)]
            public ulong Timestamp
            {
                get { return result.Timestamp; }
                set { SetTimestamp(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetTimestamp(ulong value)
            {
                PrepareBuilder();
                result.hasTimestamp = true;
                result.timestamp_ = value;
                return this;
            }
            public Builder ClearTimestamp()
            {
                PrepareBuilder();
                result.hasTimestamp = false;
                result.timestamp_ = 0UL;
                return this;
            }

            public bool HasDelay
            {
                get { return result.hasDelay; }
            }
            public int Delay
            {
                get { return result.Delay; }
                set { SetDelay(value); }
            }
            public Builder SetDelay(int value)
            {
                PrepareBuilder();
                result.hasDelay = true;
                result.delay_ = value;
                return this;
            }
            public Builder ClearDelay()
            {
                PrepareBuilder();
                result.hasDelay = false;
                result.delay_ = 0;
                return this;
            }
        }
        static TripUpdate()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class VehiclePosition : pb::ExtendableMessage<VehiclePosition, VehiclePosition.Builder>
    {
        private VehiclePosition() { }
        private static readonly VehiclePosition defaultInstance = new VehiclePosition().MakeReadOnly();
        private static readonly string[] _vehiclePositionFieldNames = new string[] { "congestion_level", "current_status", "current_stop_sequence", "occupancy_status", "position", "stop_id", "timestamp", "trip", "vehicle" };
        private static readonly uint[] _vehiclePositionFieldTags = new uint[] { 48, 32, 24, 72, 18, 58, 40, 10, 66 };
        public static VehiclePosition DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override VehiclePosition DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override VehiclePosition ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_VehiclePosition__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<VehiclePosition, VehiclePosition.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_VehiclePosition__FieldAccessorTable; }
        }

        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum VehicleStopStatus
            {
                INCOMING_AT = 0,
                STOPPED_AT = 1,
                IN_TRANSIT_TO = 2,
            }

            public enum CongestionLevel
            {
                UNKNOWN_CONGESTION_LEVEL = 0,
                RUNNING_SMOOTHLY = 1,
                STOP_AND_GO = 2,
                CONGESTION = 3,
                SEVERE_CONGESTION = 4,
            }

            public enum OccupancyStatus
            {
                EMPTY = 0,
                MANY_SEATS_AVAILABLE = 1,
                FEW_SEATS_AVAILABLE = 2,
                STANDING_ROOM_ONLY = 3,
                CRUSHED_STANDING_ROOM_ONLY = 4,
                FULL = 5,
                NOT_ACCEPTING_PASSENGERS = 6,
            }

        }
        #endregion

        public const int TripFieldNumber = 1;
        private bool hasTrip;
        private global::TransitRealtime.TripDescriptor trip_;
        public bool HasTrip
        {
            get { return hasTrip; }
        }
        public global::TransitRealtime.TripDescriptor Trip
        {
            get { return trip_ ?? global::TransitRealtime.TripDescriptor.DefaultInstance; }
        }

        public const int VehicleFieldNumber = 8;
        private bool hasVehicle;
        private global::TransitRealtime.VehicleDescriptor vehicle_;
        public bool HasVehicle
        {
            get { return hasVehicle; }
        }
        public global::TransitRealtime.VehicleDescriptor Vehicle
        {
            get { return vehicle_ ?? global::TransitRealtime.VehicleDescriptor.DefaultInstance; }
        }

        public const int PositionFieldNumber = 2;
        private bool hasPosition;
        private global::TransitRealtime.Position position_;
        public bool HasPosition
        {
            get { return hasPosition; }
        }
        public global::TransitRealtime.Position Position
        {
            get { return position_ ?? global::TransitRealtime.Position.DefaultInstance; }
        }

        public const int CurrentStopSequenceFieldNumber = 3;
        private bool hasCurrentStopSequence;
        private uint currentStopSequence_;
        public bool HasCurrentStopSequence
        {
            get { return hasCurrentStopSequence; }
        }
        [global::System.CLSCompliant(false)]
        public uint CurrentStopSequence
        {
            get { return currentStopSequence_; }
        }

        public const int StopIdFieldNumber = 7;
        private bool hasStopId;
        private string stopId_ = "";
        public bool HasStopId
        {
            get { return hasStopId; }
        }
        public string StopId
        {
            get { return stopId_; }
        }

        public const int CurrentStatusFieldNumber = 4;
        private bool hasCurrentStatus;
        private global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus currentStatus_ = global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus.IN_TRANSIT_TO;
        public bool HasCurrentStatus
        {
            get { return hasCurrentStatus; }
        }
        public global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus CurrentStatus
        {
            get { return currentStatus_; }
        }

        public const int TimestampFieldNumber = 5;
        private bool hasTimestamp;
        private ulong timestamp_;
        public bool HasTimestamp
        {
            get { return hasTimestamp; }
        }
        [global::System.CLSCompliant(false)]
        public ulong Timestamp
        {
            get { return timestamp_; }
        }

        public const int CongestionLevelFieldNumber = 6;
        private bool hasCongestionLevel;
        private global::TransitRealtime.VehiclePosition.Types.CongestionLevel congestionLevel_ = global::TransitRealtime.VehiclePosition.Types.CongestionLevel.UNKNOWN_CONGESTION_LEVEL;
        public bool HasCongestionLevel
        {
            get { return hasCongestionLevel; }
        }
        public global::TransitRealtime.VehiclePosition.Types.CongestionLevel CongestionLevel
        {
            get { return congestionLevel_; }
        }

        public const int OccupancyStatusFieldNumber = 9;
        private bool hasOccupancyStatus;
        private global::TransitRealtime.VehiclePosition.Types.OccupancyStatus occupancyStatus_ = global::TransitRealtime.VehiclePosition.Types.OccupancyStatus.EMPTY;
        public bool HasOccupancyStatus
        {
            get { return hasOccupancyStatus; }
        }
        public global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatus
        {
            get { return occupancyStatus_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (HasPosition)
                {
                    if (!Position.IsInitialized) return false;
                }
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _vehiclePositionFieldNames;
            pb::ExtendableMessage<VehiclePosition, VehiclePosition.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasTrip)
            {
                output.WriteMessage(1, field_names[7], Trip);
            }
            if (hasPosition)
            {
                output.WriteMessage(2, field_names[4], Position);
            }
            if (hasCurrentStopSequence)
            {
                output.WriteUInt32(3, field_names[2], CurrentStopSequence);
            }
            if (hasCurrentStatus)
            {
                output.WriteEnum(4, field_names[1], (int)CurrentStatus, CurrentStatus);
            }
            if (hasTimestamp)
            {
                output.WriteUInt64(5, field_names[6], Timestamp);
            }
            if (hasCongestionLevel)
            {
                output.WriteEnum(6, field_names[0], (int)CongestionLevel, CongestionLevel);
            }
            if (hasStopId)
            {
                output.WriteString(7, field_names[5], StopId);
            }
            if (hasVehicle)
            {
                output.WriteMessage(8, field_names[8], Vehicle);
            }
            if (hasOccupancyStatus)
            {
                output.WriteEnum(9, field_names[3], (int)OccupancyStatus, OccupancyStatus);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasTrip)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(1, Trip);
            }
            if (hasVehicle)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(8, Vehicle);
            }
            if (hasPosition)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(2, Position);
            }
            if (hasCurrentStopSequence)
            {
                size += pb::CodedOutputStream.ComputeUInt32Size(3, CurrentStopSequence);
            }
            if (hasStopId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(7, StopId);
            }
            if (hasCurrentStatus)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(4, (int)CurrentStatus);
            }
            if (hasTimestamp)
            {
                size += pb::CodedOutputStream.ComputeUInt64Size(5, Timestamp);
            }
            if (hasCongestionLevel)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(6, (int)CongestionLevel);
            }
            if (hasOccupancyStatus)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(9, (int)OccupancyStatus);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static VehiclePosition ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static VehiclePosition ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static VehiclePosition ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static VehiclePosition ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static VehiclePosition ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static VehiclePosition ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static VehiclePosition ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static VehiclePosition ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static VehiclePosition ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static VehiclePosition ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private VehiclePosition MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(VehiclePosition prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<VehiclePosition, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(VehiclePosition cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private VehiclePosition result;

            private VehiclePosition PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    VehiclePosition original = result;
                    result = new VehiclePosition();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override VehiclePosition MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.VehiclePosition.Descriptor; }
            }

            public override VehiclePosition DefaultInstanceForType
            {
                get { return global::TransitRealtime.VehiclePosition.DefaultInstance; }
            }

            public override VehiclePosition BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is VehiclePosition)
                {
                    return MergeFrom((VehiclePosition)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(VehiclePosition other)
            {
                if (other == global::TransitRealtime.VehiclePosition.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasTrip)
                {
                    MergeTrip(other.Trip);
                }
                if (other.HasVehicle)
                {
                    MergeVehicle(other.Vehicle);
                }
                if (other.HasPosition)
                {
                    MergePosition(other.Position);
                }
                if (other.HasCurrentStopSequence)
                {
                    CurrentStopSequence = other.CurrentStopSequence;
                }
                if (other.HasStopId)
                {
                    StopId = other.StopId;
                }
                if (other.HasCurrentStatus)
                {
                    CurrentStatus = other.CurrentStatus;
                }
                if (other.HasTimestamp)
                {
                    Timestamp = other.Timestamp;
                }
                if (other.HasCongestionLevel)
                {
                    CongestionLevel = other.CongestionLevel;
                }
                if (other.HasOccupancyStatus)
                {
                    OccupancyStatus = other.OccupancyStatus;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_vehiclePositionFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _vehiclePositionFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                global::TransitRealtime.TripDescriptor.Builder subBuilder = global::TransitRealtime.TripDescriptor.CreateBuilder();
                                if (result.hasTrip)
                                {
                                    subBuilder.MergeFrom(Trip);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Trip = subBuilder.BuildPartial();
                                break;
                            }
                        case 18:
                            {
                                global::TransitRealtime.Position.Builder subBuilder = global::TransitRealtime.Position.CreateBuilder();
                                if (result.hasPosition)
                                {
                                    subBuilder.MergeFrom(Position);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Position = subBuilder.BuildPartial();
                                break;
                            }
                        case 24:
                            {
                                result.hasCurrentStopSequence = input.ReadUInt32(ref result.currentStopSequence_);
                                break;
                            }
                        case 32:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.currentStatus_, out unknown))
                                {
                                    result.hasCurrentStatus = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(4, (ulong)(int)unknown);
                                }
                                break;
                            }
                        case 40:
                            {
                                result.hasTimestamp = input.ReadUInt64(ref result.timestamp_);
                                break;
                            }
                        case 48:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.congestionLevel_, out unknown))
                                {
                                    result.hasCongestionLevel = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(6, (ulong)(int)unknown);
                                }
                                break;
                            }
                        case 58:
                            {
                                result.hasStopId = input.ReadString(ref result.stopId_);
                                break;
                            }
                        case 66:
                            {
                                global::TransitRealtime.VehicleDescriptor.Builder subBuilder = global::TransitRealtime.VehicleDescriptor.CreateBuilder();
                                if (result.hasVehicle)
                                {
                                    subBuilder.MergeFrom(Vehicle);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Vehicle = subBuilder.BuildPartial();
                                break;
                            }
                        case 72:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.occupancyStatus_, out unknown))
                                {
                                    result.hasOccupancyStatus = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(9, (ulong)(int)unknown);
                                }
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasTrip
            {
                get { return result.hasTrip; }
            }
            public global::TransitRealtime.TripDescriptor Trip
            {
                get { return result.Trip; }
                set { SetTrip(value); }
            }
            public Builder SetTrip(global::TransitRealtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = value;
                return this;
            }
            public Builder SetTrip(global::TransitRealtime.TripDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = builderForValue.Build();
                return this;
            }
            public Builder MergeTrip(global::TransitRealtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTrip &&
                    result.trip_ != global::TransitRealtime.TripDescriptor.DefaultInstance)
                {
                    result.trip_ = global::TransitRealtime.TripDescriptor.CreateBuilder(result.trip_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.trip_ = value;
                }
                result.hasTrip = true;
                return this;
            }
            public Builder ClearTrip()
            {
                PrepareBuilder();
                result.hasTrip = false;
                result.trip_ = null;
                return this;
            }

            public bool HasVehicle
            {
                get { return result.hasVehicle; }
            }
            public global::TransitRealtime.VehicleDescriptor Vehicle
            {
                get { return result.Vehicle; }
                set { SetVehicle(value); }
            }
            public Builder SetVehicle(global::TransitRealtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = value;
                return this;
            }
            public Builder SetVehicle(global::TransitRealtime.VehicleDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasVehicle = true;
                result.vehicle_ = builderForValue.Build();
                return this;
            }
            public Builder MergeVehicle(global::TransitRealtime.VehicleDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasVehicle &&
                    result.vehicle_ != global::TransitRealtime.VehicleDescriptor.DefaultInstance)
                {
                    result.vehicle_ = global::TransitRealtime.VehicleDescriptor.CreateBuilder(result.vehicle_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.vehicle_ = value;
                }
                result.hasVehicle = true;
                return this;
            }
            public Builder ClearVehicle()
            {
                PrepareBuilder();
                result.hasVehicle = false;
                result.vehicle_ = null;
                return this;
            }

            public bool HasPosition
            {
                get { return result.hasPosition; }
            }
            public global::TransitRealtime.Position Position
            {
                get { return result.Position; }
                set { SetPosition(value); }
            }
            public Builder SetPosition(global::TransitRealtime.Position value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasPosition = true;
                result.position_ = value;
                return this;
            }
            public Builder SetPosition(global::TransitRealtime.Position.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasPosition = true;
                result.position_ = builderForValue.Build();
                return this;
            }
            public Builder MergePosition(global::TransitRealtime.Position value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasPosition &&
                    result.position_ != global::TransitRealtime.Position.DefaultInstance)
                {
                    result.position_ = global::TransitRealtime.Position.CreateBuilder(result.position_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.position_ = value;
                }
                result.hasPosition = true;
                return this;
            }
            public Builder ClearPosition()
            {
                PrepareBuilder();
                result.hasPosition = false;
                result.position_ = null;
                return this;
            }

            public bool HasCurrentStopSequence
            {
                get { return result.hasCurrentStopSequence; }
            }
            [global::System.CLSCompliant(false)]
            public uint CurrentStopSequence
            {
                get { return result.CurrentStopSequence; }
                set { SetCurrentStopSequence(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetCurrentStopSequence(uint value)
            {
                PrepareBuilder();
                result.hasCurrentStopSequence = true;
                result.currentStopSequence_ = value;
                return this;
            }
            public Builder ClearCurrentStopSequence()
            {
                PrepareBuilder();
                result.hasCurrentStopSequence = false;
                result.currentStopSequence_ = 0;
                return this;
            }

            public bool HasStopId
            {
                get { return result.hasStopId; }
            }
            public string StopId
            {
                get { return result.StopId; }
                set { SetStopId(value); }
            }
            public Builder SetStopId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStopId = true;
                result.stopId_ = value;
                return this;
            }
            public Builder ClearStopId()
            {
                PrepareBuilder();
                result.hasStopId = false;
                result.stopId_ = "";
                return this;
            }

            public bool HasCurrentStatus
            {
                get { return result.hasCurrentStatus; }
            }
            public global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus CurrentStatus
            {
                get { return result.CurrentStatus; }
                set { SetCurrentStatus(value); }
            }
            public Builder SetCurrentStatus(global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus value)
            {
                PrepareBuilder();
                result.hasCurrentStatus = true;
                result.currentStatus_ = value;
                return this;
            }
            public Builder ClearCurrentStatus()
            {
                PrepareBuilder();
                result.hasCurrentStatus = false;
                result.currentStatus_ = global::TransitRealtime.VehiclePosition.Types.VehicleStopStatus.IN_TRANSIT_TO;
                return this;
            }

            public bool HasTimestamp
            {
                get { return result.hasTimestamp; }
            }
            [global::System.CLSCompliant(false)]
            public ulong Timestamp
            {
                get { return result.Timestamp; }
                set { SetTimestamp(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetTimestamp(ulong value)
            {
                PrepareBuilder();
                result.hasTimestamp = true;
                result.timestamp_ = value;
                return this;
            }
            public Builder ClearTimestamp()
            {
                PrepareBuilder();
                result.hasTimestamp = false;
                result.timestamp_ = 0UL;
                return this;
            }

            public bool HasCongestionLevel
            {
                get { return result.hasCongestionLevel; }
            }
            public global::TransitRealtime.VehiclePosition.Types.CongestionLevel CongestionLevel
            {
                get { return result.CongestionLevel; }
                set { SetCongestionLevel(value); }
            }
            public Builder SetCongestionLevel(global::TransitRealtime.VehiclePosition.Types.CongestionLevel value)
            {
                PrepareBuilder();
                result.hasCongestionLevel = true;
                result.congestionLevel_ = value;
                return this;
            }
            public Builder ClearCongestionLevel()
            {
                PrepareBuilder();
                result.hasCongestionLevel = false;
                result.congestionLevel_ = global::TransitRealtime.VehiclePosition.Types.CongestionLevel.UNKNOWN_CONGESTION_LEVEL;
                return this;
            }

            public bool HasOccupancyStatus
            {
                get { return result.hasOccupancyStatus; }
            }
            public global::TransitRealtime.VehiclePosition.Types.OccupancyStatus OccupancyStatus
            {
                get { return result.OccupancyStatus; }
                set { SetOccupancyStatus(value); }
            }
            public Builder SetOccupancyStatus(global::TransitRealtime.VehiclePosition.Types.OccupancyStatus value)
            {
                PrepareBuilder();
                result.hasOccupancyStatus = true;
                result.occupancyStatus_ = value;
                return this;
            }
            public Builder ClearOccupancyStatus()
            {
                PrepareBuilder();
                result.hasOccupancyStatus = false;
                result.occupancyStatus_ = global::TransitRealtime.VehiclePosition.Types.OccupancyStatus.EMPTY;
                return this;
            }
        }
        static VehiclePosition()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Alert : pb::ExtendableMessage<Alert, Alert.Builder>
    {
        private Alert() { }
        private static readonly Alert defaultInstance = new Alert().MakeReadOnly();
        private static readonly string[] _alertFieldNames = new string[] { "active_period", "cause", "description_text", "effect", "header_text", "informed_entity", "url" };
        private static readonly uint[] _alertFieldTags = new uint[] { 10, 48, 90, 56, 82, 42, 66 };
        public static Alert DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override Alert DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override Alert ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_Alert__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<Alert, Alert.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_Alert__FieldAccessorTable; }
        }

        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum Cause
            {
                UNKNOWN_CAUSE = 1,
                OTHER_CAUSE = 2,
                TECHNICAL_PROBLEM = 3,
                STRIKE = 4,
                DEMONSTRATION = 5,
                ACCIDENT = 6,
                HOLIDAY = 7,
                WEATHER = 8,
                MAINTENANCE = 9,
                CONSTRUCTION = 10,
                POLICE_ACTIVITY = 11,
                MEDICAL_EMERGENCY = 12,
            }

            public enum Effect
            {
                NO_SERVICE = 1,
                REDUCED_SERVICE = 2,
                SIGNIFICANT_DELAYS = 3,
                DETOUR = 4,
                ADDITIONAL_SERVICE = 5,
                MODIFIED_SERVICE = 6,
                OTHER_EFFECT = 7,
                UNKNOWN_EFFECT = 8,
                STOP_MOVED = 9,
            }

        }
        #endregion

        public const int ActivePeriodFieldNumber = 1;
        private pbc::PopsicleList<global::TransitRealtime.TimeRange> activePeriod_ = new pbc::PopsicleList<global::TransitRealtime.TimeRange>();
        public scg::IList<global::TransitRealtime.TimeRange> ActivePeriodList
        {
            get { return activePeriod_; }
        }
        public int ActivePeriodCount
        {
            get { return activePeriod_.Count; }
        }
        public global::TransitRealtime.TimeRange GetActivePeriod(int index)
        {
            return activePeriod_[index];
        }

        public const int InformedEntityFieldNumber = 5;
        private pbc::PopsicleList<global::TransitRealtime.EntitySelector> informedEntity_ = new pbc::PopsicleList<global::TransitRealtime.EntitySelector>();
        public scg::IList<global::TransitRealtime.EntitySelector> InformedEntityList
        {
            get { return informedEntity_; }
        }
        public int InformedEntityCount
        {
            get { return informedEntity_.Count; }
        }
        public global::TransitRealtime.EntitySelector GetInformedEntity(int index)
        {
            return informedEntity_[index];
        }

        public const int CauseFieldNumber = 6;
        private bool hasCause;
        private global::TransitRealtime.Alert.Types.Cause cause_ = global::TransitRealtime.Alert.Types.Cause.UNKNOWN_CAUSE;
        public bool HasCause
        {
            get { return hasCause; }
        }
        public global::TransitRealtime.Alert.Types.Cause Cause
        {
            get { return cause_; }
        }

        public const int EffectFieldNumber = 7;
        private bool hasEffect;
        private global::TransitRealtime.Alert.Types.Effect effect_ = global::TransitRealtime.Alert.Types.Effect.UNKNOWN_EFFECT;
        public bool HasEffect
        {
            get { return hasEffect; }
        }
        public global::TransitRealtime.Alert.Types.Effect Effect
        {
            get { return effect_; }
        }

        public const int UrlFieldNumber = 8;
        private bool hasUrl;
        private global::TransitRealtime.TranslatedString url_;
        public bool HasUrl
        {
            get { return hasUrl; }
        }
        public global::TransitRealtime.TranslatedString Url
        {
            get { return url_ ?? global::TransitRealtime.TranslatedString.DefaultInstance; }
        }

        public const int HeaderTextFieldNumber = 10;
        private bool hasHeaderText;
        private global::TransitRealtime.TranslatedString headerText_;
        public bool HasHeaderText
        {
            get { return hasHeaderText; }
        }
        public global::TransitRealtime.TranslatedString HeaderText
        {
            get { return headerText_ ?? global::TransitRealtime.TranslatedString.DefaultInstance; }
        }

        public const int DescriptionTextFieldNumber = 11;
        private bool hasDescriptionText;
        private global::TransitRealtime.TranslatedString descriptionText_;
        public bool HasDescriptionText
        {
            get { return hasDescriptionText; }
        }
        public global::TransitRealtime.TranslatedString DescriptionText
        {
            get { return descriptionText_ ?? global::TransitRealtime.TranslatedString.DefaultInstance; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (HasUrl)
                {
                    if (!Url.IsInitialized) return false;
                }
                if (HasHeaderText)
                {
                    if (!HeaderText.IsInitialized) return false;
                }
                if (HasDescriptionText)
                {
                    if (!DescriptionText.IsInitialized) return false;
                }
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _alertFieldNames;
            pb::ExtendableMessage<Alert, Alert.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (activePeriod_.Count > 0)
            {
                output.WriteMessageArray(1, field_names[0], activePeriod_);
            }
            if (informedEntity_.Count > 0)
            {
                output.WriteMessageArray(5, field_names[5], informedEntity_);
            }
            if (hasCause)
            {
                output.WriteEnum(6, field_names[1], (int)Cause, Cause);
            }
            if (hasEffect)
            {
                output.WriteEnum(7, field_names[3], (int)Effect, Effect);
            }
            if (hasUrl)
            {
                output.WriteMessage(8, field_names[6], Url);
            }
            if (hasHeaderText)
            {
                output.WriteMessage(10, field_names[4], HeaderText);
            }
            if (hasDescriptionText)
            {
                output.WriteMessage(11, field_names[2], DescriptionText);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            foreach (global::TransitRealtime.TimeRange element in ActivePeriodList)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(1, element);
            }
            foreach (global::TransitRealtime.EntitySelector element in InformedEntityList)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(5, element);
            }
            if (hasCause)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(6, (int)Cause);
            }
            if (hasEffect)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(7, (int)Effect);
            }
            if (hasUrl)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(8, Url);
            }
            if (hasHeaderText)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(10, HeaderText);
            }
            if (hasDescriptionText)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(11, DescriptionText);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static Alert ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Alert ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Alert ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Alert ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Alert ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Alert ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Alert ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Alert ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Alert ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Alert ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Alert MakeReadOnly()
        {
            activePeriod_.MakeReadOnly();
            informedEntity_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Alert prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<Alert, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(Alert cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private Alert result;

            private Alert PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    Alert original = result;
                    result = new Alert();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override Alert MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.Alert.Descriptor; }
            }

            public override Alert DefaultInstanceForType
            {
                get { return global::TransitRealtime.Alert.DefaultInstance; }
            }

            public override Alert BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is Alert)
                {
                    return MergeFrom((Alert)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(Alert other)
            {
                if (other == global::TransitRealtime.Alert.DefaultInstance) return this;
                PrepareBuilder();
                if (other.activePeriod_.Count != 0)
                {
                    result.activePeriod_.Add(other.activePeriod_);
                }
                if (other.informedEntity_.Count != 0)
                {
                    result.informedEntity_.Add(other.informedEntity_);
                }
                if (other.HasCause)
                {
                    Cause = other.Cause;
                }
                if (other.HasEffect)
                {
                    Effect = other.Effect;
                }
                if (other.HasUrl)
                {
                    MergeUrl(other.Url);
                }
                if (other.HasHeaderText)
                {
                    MergeHeaderText(other.HeaderText);
                }
                if (other.HasDescriptionText)
                {
                    MergeDescriptionText(other.DescriptionText);
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_alertFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _alertFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                input.ReadMessageArray(tag, field_name, result.activePeriod_, global::TransitRealtime.TimeRange.DefaultInstance, extensionRegistry);
                                break;
                            }
                        case 42:
                            {
                                input.ReadMessageArray(tag, field_name, result.informedEntity_, global::TransitRealtime.EntitySelector.DefaultInstance, extensionRegistry);
                                break;
                            }
                        case 48:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.cause_, out unknown))
                                {
                                    result.hasCause = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(6, (ulong)(int)unknown);
                                }
                                break;
                            }
                        case 56:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.effect_, out unknown))
                                {
                                    result.hasEffect = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(7, (ulong)(int)unknown);
                                }
                                break;
                            }
                        case 66:
                            {
                                global::TransitRealtime.TranslatedString.Builder subBuilder = global::TransitRealtime.TranslatedString.CreateBuilder();
                                if (result.hasUrl)
                                {
                                    subBuilder.MergeFrom(Url);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Url = subBuilder.BuildPartial();
                                break;
                            }
                        case 82:
                            {
                                global::TransitRealtime.TranslatedString.Builder subBuilder = global::TransitRealtime.TranslatedString.CreateBuilder();
                                if (result.hasHeaderText)
                                {
                                    subBuilder.MergeFrom(HeaderText);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                HeaderText = subBuilder.BuildPartial();
                                break;
                            }
                        case 90:
                            {
                                global::TransitRealtime.TranslatedString.Builder subBuilder = global::TransitRealtime.TranslatedString.CreateBuilder();
                                if (result.hasDescriptionText)
                                {
                                    subBuilder.MergeFrom(DescriptionText);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                DescriptionText = subBuilder.BuildPartial();
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public pbc::IPopsicleList<global::TransitRealtime.TimeRange> ActivePeriodList
            {
                get { return PrepareBuilder().activePeriod_; }
            }
            public int ActivePeriodCount
            {
                get { return result.ActivePeriodCount; }
            }
            public global::TransitRealtime.TimeRange GetActivePeriod(int index)
            {
                return result.GetActivePeriod(index);
            }
            public Builder SetActivePeriod(int index, global::TransitRealtime.TimeRange value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.activePeriod_[index] = value;
                return this;
            }
            public Builder SetActivePeriod(int index, global::TransitRealtime.TimeRange.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.activePeriod_[index] = builderForValue.Build();
                return this;
            }
            public Builder AddActivePeriod(global::TransitRealtime.TimeRange value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.activePeriod_.Add(value);
                return this;
            }
            public Builder AddActivePeriod(global::TransitRealtime.TimeRange.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.activePeriod_.Add(builderForValue.Build());
                return this;
            }
            public Builder AddRangeActivePeriod(scg::IEnumerable<global::TransitRealtime.TimeRange> values)
            {
                PrepareBuilder();
                result.activePeriod_.Add(values);
                return this;
            }
            public Builder ClearActivePeriod()
            {
                PrepareBuilder();
                result.activePeriod_.Clear();
                return this;
            }

            public pbc::IPopsicleList<global::TransitRealtime.EntitySelector> InformedEntityList
            {
                get { return PrepareBuilder().informedEntity_; }
            }
            public int InformedEntityCount
            {
                get { return result.InformedEntityCount; }
            }
            public global::TransitRealtime.EntitySelector GetInformedEntity(int index)
            {
                return result.GetInformedEntity(index);
            }
            public Builder SetInformedEntity(int index, global::TransitRealtime.EntitySelector value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.informedEntity_[index] = value;
                return this;
            }
            public Builder SetInformedEntity(int index, global::TransitRealtime.EntitySelector.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.informedEntity_[index] = builderForValue.Build();
                return this;
            }
            public Builder AddInformedEntity(global::TransitRealtime.EntitySelector value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.informedEntity_.Add(value);
                return this;
            }
            public Builder AddInformedEntity(global::TransitRealtime.EntitySelector.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.informedEntity_.Add(builderForValue.Build());
                return this;
            }
            public Builder AddRangeInformedEntity(scg::IEnumerable<global::TransitRealtime.EntitySelector> values)
            {
                PrepareBuilder();
                result.informedEntity_.Add(values);
                return this;
            }
            public Builder ClearInformedEntity()
            {
                PrepareBuilder();
                result.informedEntity_.Clear();
                return this;
            }

            public bool HasCause
            {
                get { return result.hasCause; }
            }
            public global::TransitRealtime.Alert.Types.Cause Cause
            {
                get { return result.Cause; }
                set { SetCause(value); }
            }
            public Builder SetCause(global::TransitRealtime.Alert.Types.Cause value)
            {
                PrepareBuilder();
                result.hasCause = true;
                result.cause_ = value;
                return this;
            }
            public Builder ClearCause()
            {
                PrepareBuilder();
                result.hasCause = false;
                result.cause_ = global::TransitRealtime.Alert.Types.Cause.UNKNOWN_CAUSE;
                return this;
            }

            public bool HasEffect
            {
                get { return result.hasEffect; }
            }
            public global::TransitRealtime.Alert.Types.Effect Effect
            {
                get { return result.Effect; }
                set { SetEffect(value); }
            }
            public Builder SetEffect(global::TransitRealtime.Alert.Types.Effect value)
            {
                PrepareBuilder();
                result.hasEffect = true;
                result.effect_ = value;
                return this;
            }
            public Builder ClearEffect()
            {
                PrepareBuilder();
                result.hasEffect = false;
                result.effect_ = global::TransitRealtime.Alert.Types.Effect.UNKNOWN_EFFECT;
                return this;
            }

            public bool HasUrl
            {
                get { return result.hasUrl; }
            }
            public global::TransitRealtime.TranslatedString Url
            {
                get { return result.Url; }
                set { SetUrl(value); }
            }
            public Builder SetUrl(global::TransitRealtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasUrl = true;
                result.url_ = value;
                return this;
            }
            public Builder SetUrl(global::TransitRealtime.TranslatedString.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasUrl = true;
                result.url_ = builderForValue.Build();
                return this;
            }
            public Builder MergeUrl(global::TransitRealtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasUrl &&
                    result.url_ != global::TransitRealtime.TranslatedString.DefaultInstance)
                {
                    result.url_ = global::TransitRealtime.TranslatedString.CreateBuilder(result.url_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.url_ = value;
                }
                result.hasUrl = true;
                return this;
            }
            public Builder ClearUrl()
            {
                PrepareBuilder();
                result.hasUrl = false;
                result.url_ = null;
                return this;
            }

            public bool HasHeaderText
            {
                get { return result.hasHeaderText; }
            }
            public global::TransitRealtime.TranslatedString HeaderText
            {
                get { return result.HeaderText; }
                set { SetHeaderText(value); }
            }
            public Builder SetHeaderText(global::TransitRealtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasHeaderText = true;
                result.headerText_ = value;
                return this;
            }
            public Builder SetHeaderText(global::TransitRealtime.TranslatedString.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasHeaderText = true;
                result.headerText_ = builderForValue.Build();
                return this;
            }
            public Builder MergeHeaderText(global::TransitRealtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasHeaderText &&
                    result.headerText_ != global::TransitRealtime.TranslatedString.DefaultInstance)
                {
                    result.headerText_ = global::TransitRealtime.TranslatedString.CreateBuilder(result.headerText_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.headerText_ = value;
                }
                result.hasHeaderText = true;
                return this;
            }
            public Builder ClearHeaderText()
            {
                PrepareBuilder();
                result.hasHeaderText = false;
                result.headerText_ = null;
                return this;
            }

            public bool HasDescriptionText
            {
                get { return result.hasDescriptionText; }
            }
            public global::TransitRealtime.TranslatedString DescriptionText
            {
                get { return result.DescriptionText; }
                set { SetDescriptionText(value); }
            }
            public Builder SetDescriptionText(global::TransitRealtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasDescriptionText = true;
                result.descriptionText_ = value;
                return this;
            }
            public Builder SetDescriptionText(global::TransitRealtime.TranslatedString.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasDescriptionText = true;
                result.descriptionText_ = builderForValue.Build();
                return this;
            }
            public Builder MergeDescriptionText(global::TransitRealtime.TranslatedString value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasDescriptionText &&
                    result.descriptionText_ != global::TransitRealtime.TranslatedString.DefaultInstance)
                {
                    result.descriptionText_ = global::TransitRealtime.TranslatedString.CreateBuilder(result.descriptionText_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.descriptionText_ = value;
                }
                result.hasDescriptionText = true;
                return this;
            }
            public Builder ClearDescriptionText()
            {
                PrepareBuilder();
                result.hasDescriptionText = false;
                result.descriptionText_ = null;
                return this;
            }
        }
        static Alert()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TimeRange : pb::ExtendableMessage<TimeRange, TimeRange.Builder>
    {
        private TimeRange() { }
        private static readonly TimeRange defaultInstance = new TimeRange().MakeReadOnly();
        private static readonly string[] _timeRangeFieldNames = new string[] { "end", "start" };
        private static readonly uint[] _timeRangeFieldTags = new uint[] { 16, 8 };
        public static TimeRange DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TimeRange DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TimeRange ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TimeRange__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TimeRange, TimeRange.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TimeRange__FieldAccessorTable; }
        }

        public const int StartFieldNumber = 1;
        private bool hasStart;
        private ulong start_;
        public bool HasStart
        {
            get { return hasStart; }
        }
        [global::System.CLSCompliant(false)]
        public ulong Start
        {
            get { return start_; }
        }

        public const int EndFieldNumber = 2;
        private bool hasEnd;
        private ulong end_;
        public bool HasEnd
        {
            get { return hasEnd; }
        }
        [global::System.CLSCompliant(false)]
        public ulong End
        {
            get { return end_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _timeRangeFieldNames;
            pb::ExtendableMessage<TimeRange, TimeRange.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasStart)
            {
                output.WriteUInt64(1, field_names[1], Start);
            }
            if (hasEnd)
            {
                output.WriteUInt64(2, field_names[0], End);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasStart)
            {
                size += pb::CodedOutputStream.ComputeUInt64Size(1, Start);
            }
            if (hasEnd)
            {
                size += pb::CodedOutputStream.ComputeUInt64Size(2, End);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static TimeRange ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TimeRange ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TimeRange ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TimeRange ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TimeRange ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TimeRange ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static TimeRange ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static TimeRange ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static TimeRange ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TimeRange ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private TimeRange MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(TimeRange prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<TimeRange, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(TimeRange cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private TimeRange result;

            private TimeRange PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    TimeRange original = result;
                    result = new TimeRange();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TimeRange MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.TimeRange.Descriptor; }
            }

            public override TimeRange DefaultInstanceForType
            {
                get { return global::TransitRealtime.TimeRange.DefaultInstance; }
            }

            public override TimeRange BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TimeRange)
                {
                    return MergeFrom((TimeRange)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TimeRange other)
            {
                if (other == global::TransitRealtime.TimeRange.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasStart)
                {
                    Start = other.Start;
                }
                if (other.HasEnd)
                {
                    End = other.End;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_timeRangeFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _timeRangeFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 8:
                            {
                                result.hasStart = input.ReadUInt64(ref result.start_);
                                break;
                            }
                        case 16:
                            {
                                result.hasEnd = input.ReadUInt64(ref result.end_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasStart
            {
                get { return result.hasStart; }
            }
            [global::System.CLSCompliant(false)]
            public ulong Start
            {
                get { return result.Start; }
                set { SetStart(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetStart(ulong value)
            {
                PrepareBuilder();
                result.hasStart = true;
                result.start_ = value;
                return this;
            }
            public Builder ClearStart()
            {
                PrepareBuilder();
                result.hasStart = false;
                result.start_ = 0UL;
                return this;
            }

            public bool HasEnd
            {
                get { return result.hasEnd; }
            }
            [global::System.CLSCompliant(false)]
            public ulong End
            {
                get { return result.End; }
                set { SetEnd(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetEnd(ulong value)
            {
                PrepareBuilder();
                result.hasEnd = true;
                result.end_ = value;
                return this;
            }
            public Builder ClearEnd()
            {
                PrepareBuilder();
                result.hasEnd = false;
                result.end_ = 0UL;
                return this;
            }
        }
        static TimeRange()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Position : pb::ExtendableMessage<Position, Position.Builder>
    {
        private Position() { }
        private static readonly Position defaultInstance = new Position().MakeReadOnly();
        private static readonly string[] _positionFieldNames = new string[] { "bearing", "latitude", "longitude", "odometer", "speed" };
        private static readonly uint[] _positionFieldTags = new uint[] { 29, 13, 21, 33, 45 };
        public static Position DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override Position DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override Position ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_Position__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<Position, Position.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_Position__FieldAccessorTable; }
        }

        public const int LatitudeFieldNumber = 1;
        private bool hasLatitude;
        private float latitude_;
        public bool HasLatitude
        {
            get { return hasLatitude; }
        }
        public float Latitude
        {
            get { return latitude_; }
        }

        public const int LongitudeFieldNumber = 2;
        private bool hasLongitude;
        private float longitude_;
        public bool HasLongitude
        {
            get { return hasLongitude; }
        }
        public float Longitude
        {
            get { return longitude_; }
        }

        public const int BearingFieldNumber = 3;
        private bool hasBearing;
        private float bearing_;
        public bool HasBearing
        {
            get { return hasBearing; }
        }
        public float Bearing
        {
            get { return bearing_; }
        }

        public const int OdometerFieldNumber = 4;
        private bool hasOdometer;
        private double odometer_;
        public bool HasOdometer
        {
            get { return hasOdometer; }
        }
        public double Odometer
        {
            get { return odometer_; }
        }

        public const int SpeedFieldNumber = 5;
        private bool hasSpeed;
        private float speed_;
        public bool HasSpeed
        {
            get { return hasSpeed; }
        }
        public float Speed
        {
            get { return speed_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!hasLatitude) return false;
                if (!hasLongitude) return false;
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _positionFieldNames;
            pb::ExtendableMessage<Position, Position.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasLatitude)
            {
                output.WriteFloat(1, field_names[1], Latitude);
            }
            if (hasLongitude)
            {
                output.WriteFloat(2, field_names[2], Longitude);
            }
            if (hasBearing)
            {
                output.WriteFloat(3, field_names[0], Bearing);
            }
            if (hasOdometer)
            {
                output.WriteDouble(4, field_names[3], Odometer);
            }
            if (hasSpeed)
            {
                output.WriteFloat(5, field_names[4], Speed);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasLatitude)
            {
                size += pb::CodedOutputStream.ComputeFloatSize(1, Latitude);
            }
            if (hasLongitude)
            {
                size += pb::CodedOutputStream.ComputeFloatSize(2, Longitude);
            }
            if (hasBearing)
            {
                size += pb::CodedOutputStream.ComputeFloatSize(3, Bearing);
            }
            if (hasOdometer)
            {
                size += pb::CodedOutputStream.ComputeDoubleSize(4, Odometer);
            }
            if (hasSpeed)
            {
                size += pb::CodedOutputStream.ComputeFloatSize(5, Speed);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static Position ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Position ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Position ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Position ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Position ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Position ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Position ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Position ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Position ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Position ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Position MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Position prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<Position, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(Position cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private Position result;

            private Position PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    Position original = result;
                    result = new Position();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override Position MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.Position.Descriptor; }
            }

            public override Position DefaultInstanceForType
            {
                get { return global::TransitRealtime.Position.DefaultInstance; }
            }

            public override Position BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is Position)
                {
                    return MergeFrom((Position)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(Position other)
            {
                if (other == global::TransitRealtime.Position.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasLatitude)
                {
                    Latitude = other.Latitude;
                }
                if (other.HasLongitude)
                {
                    Longitude = other.Longitude;
                }
                if (other.HasBearing)
                {
                    Bearing = other.Bearing;
                }
                if (other.HasOdometer)
                {
                    Odometer = other.Odometer;
                }
                if (other.HasSpeed)
                {
                    Speed = other.Speed;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_positionFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _positionFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 13:
                            {
                                result.hasLatitude = input.ReadFloat(ref result.latitude_);
                                break;
                            }
                        case 21:
                            {
                                result.hasLongitude = input.ReadFloat(ref result.longitude_);
                                break;
                            }
                        case 29:
                            {
                                result.hasBearing = input.ReadFloat(ref result.bearing_);
                                break;
                            }
                        case 33:
                            {
                                result.hasOdometer = input.ReadDouble(ref result.odometer_);
                                break;
                            }
                        case 45:
                            {
                                result.hasSpeed = input.ReadFloat(ref result.speed_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasLatitude
            {
                get { return result.hasLatitude; }
            }
            public float Latitude
            {
                get { return result.Latitude; }
                set { SetLatitude(value); }
            }
            public Builder SetLatitude(float value)
            {
                PrepareBuilder();
                result.hasLatitude = true;
                result.latitude_ = value;
                return this;
            }
            public Builder ClearLatitude()
            {
                PrepareBuilder();
                result.hasLatitude = false;
                result.latitude_ = 0F;
                return this;
            }

            public bool HasLongitude
            {
                get { return result.hasLongitude; }
            }
            public float Longitude
            {
                get { return result.Longitude; }
                set { SetLongitude(value); }
            }
            public Builder SetLongitude(float value)
            {
                PrepareBuilder();
                result.hasLongitude = true;
                result.longitude_ = value;
                return this;
            }
            public Builder ClearLongitude()
            {
                PrepareBuilder();
                result.hasLongitude = false;
                result.longitude_ = 0F;
                return this;
            }

            public bool HasBearing
            {
                get { return result.hasBearing; }
            }
            public float Bearing
            {
                get { return result.Bearing; }
                set { SetBearing(value); }
            }
            public Builder SetBearing(float value)
            {
                PrepareBuilder();
                result.hasBearing = true;
                result.bearing_ = value;
                return this;
            }
            public Builder ClearBearing()
            {
                PrepareBuilder();
                result.hasBearing = false;
                result.bearing_ = 0F;
                return this;
            }

            public bool HasOdometer
            {
                get { return result.hasOdometer; }
            }
            public double Odometer
            {
                get { return result.Odometer; }
                set { SetOdometer(value); }
            }
            public Builder SetOdometer(double value)
            {
                PrepareBuilder();
                result.hasOdometer = true;
                result.odometer_ = value;
                return this;
            }
            public Builder ClearOdometer()
            {
                PrepareBuilder();
                result.hasOdometer = false;
                result.odometer_ = 0D;
                return this;
            }

            public bool HasSpeed
            {
                get { return result.hasSpeed; }
            }
            public float Speed
            {
                get { return result.Speed; }
                set { SetSpeed(value); }
            }
            public Builder SetSpeed(float value)
            {
                PrepareBuilder();
                result.hasSpeed = true;
                result.speed_ = value;
                return this;
            }
            public Builder ClearSpeed()
            {
                PrepareBuilder();
                result.hasSpeed = false;
                result.speed_ = 0F;
                return this;
            }
        }
        static Position()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TripDescriptor : pb::ExtendableMessage<TripDescriptor, TripDescriptor.Builder>
    {
        private TripDescriptor() { }
        private static readonly TripDescriptor defaultInstance = new TripDescriptor().MakeReadOnly();
        private static readonly string[] _tripDescriptorFieldNames = new string[] { "direction_id", "route_id", "schedule_relationship", "start_date", "start_time", "trip_id" };
        private static readonly uint[] _tripDescriptorFieldTags = new uint[] { 48, 42, 32, 26, 18, 10 };
        public static TripDescriptor DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TripDescriptor DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TripDescriptor ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripDescriptor__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TripDescriptor, TripDescriptor.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TripDescriptor__FieldAccessorTable; }
        }

        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            public enum ScheduleRelationship
            {
                SCHEDULED = 0,
                ADDED = 1,
                UNSCHEDULED = 2,
                CANCELED = 3,
            }

        }
        #endregion

        public const int TripIdFieldNumber = 1;
        private bool hasTripId;
        private string tripId_ = "";
        public bool HasTripId
        {
            get { return hasTripId; }
        }
        public string TripId
        {
            get { return tripId_; }
        }

        public const int RouteIdFieldNumber = 5;
        private bool hasRouteId;
        private string routeId_ = "";
        public bool HasRouteId
        {
            get { return hasRouteId; }
        }
        public string RouteId
        {
            get { return routeId_; }
        }

        public const int DirectionIdFieldNumber = 6;
        private bool hasDirectionId;
        private uint directionId_;
        public bool HasDirectionId
        {
            get { return hasDirectionId; }
        }
        [global::System.CLSCompliant(false)]
        public uint DirectionId
        {
            get { return directionId_; }
        }

        public const int StartTimeFieldNumber = 2;
        private bool hasStartTime;
        private string startTime_ = "";
        public bool HasStartTime
        {
            get { return hasStartTime; }
        }
        public string StartTime
        {
            get { return startTime_; }
        }

        public const int StartDateFieldNumber = 3;
        private bool hasStartDate;
        private string startDate_ = "";
        public bool HasStartDate
        {
            get { return hasStartDate; }
        }
        public string StartDate
        {
            get { return startDate_; }
        }

        public const int ScheduleRelationshipFieldNumber = 4;
        private bool hasScheduleRelationship;
        private global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship scheduleRelationship_ = global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship.SCHEDULED;
        public bool HasScheduleRelationship
        {
            get { return hasScheduleRelationship; }
        }
        public global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship
        {
            get { return scheduleRelationship_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _tripDescriptorFieldNames;
            pb::ExtendableMessage<TripDescriptor, TripDescriptor.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasTripId)
            {
                output.WriteString(1, field_names[5], TripId);
            }
            if (hasStartTime)
            {
                output.WriteString(2, field_names[4], StartTime);
            }
            if (hasStartDate)
            {
                output.WriteString(3, field_names[3], StartDate);
            }
            if (hasScheduleRelationship)
            {
                output.WriteEnum(4, field_names[2], (int)ScheduleRelationship, ScheduleRelationship);
            }
            if (hasRouteId)
            {
                output.WriteString(5, field_names[1], RouteId);
            }
            if (hasDirectionId)
            {
                output.WriteUInt32(6, field_names[0], DirectionId);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasTripId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(1, TripId);
            }
            if (hasRouteId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(5, RouteId);
            }
            if (hasDirectionId)
            {
                size += pb::CodedOutputStream.ComputeUInt32Size(6, DirectionId);
            }
            if (hasStartTime)
            {
                size += pb::CodedOutputStream.ComputeStringSize(2, StartTime);
            }
            if (hasStartDate)
            {
                size += pb::CodedOutputStream.ComputeStringSize(3, StartDate);
            }
            if (hasScheduleRelationship)
            {
                size += pb::CodedOutputStream.ComputeEnumSize(4, (int)ScheduleRelationship);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static TripDescriptor ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TripDescriptor ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TripDescriptor ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TripDescriptor ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TripDescriptor ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TripDescriptor ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static TripDescriptor ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static TripDescriptor ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static TripDescriptor ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TripDescriptor ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private TripDescriptor MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(TripDescriptor prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<TripDescriptor, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(TripDescriptor cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private TripDescriptor result;

            private TripDescriptor PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    TripDescriptor original = result;
                    result = new TripDescriptor();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TripDescriptor MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.TripDescriptor.Descriptor; }
            }

            public override TripDescriptor DefaultInstanceForType
            {
                get { return global::TransitRealtime.TripDescriptor.DefaultInstance; }
            }

            public override TripDescriptor BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TripDescriptor)
                {
                    return MergeFrom((TripDescriptor)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TripDescriptor other)
            {
                if (other == global::TransitRealtime.TripDescriptor.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasTripId)
                {
                    TripId = other.TripId;
                }
                if (other.HasRouteId)
                {
                    RouteId = other.RouteId;
                }
                if (other.HasDirectionId)
                {
                    DirectionId = other.DirectionId;
                }
                if (other.HasStartTime)
                {
                    StartTime = other.StartTime;
                }
                if (other.HasStartDate)
                {
                    StartDate = other.StartDate;
                }
                if (other.HasScheduleRelationship)
                {
                    ScheduleRelationship = other.ScheduleRelationship;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_tripDescriptorFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _tripDescriptorFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                result.hasTripId = input.ReadString(ref result.tripId_);
                                break;
                            }
                        case 18:
                            {
                                result.hasStartTime = input.ReadString(ref result.startTime_);
                                break;
                            }
                        case 26:
                            {
                                result.hasStartDate = input.ReadString(ref result.startDate_);
                                break;
                            }
                        case 32:
                            {
                                object unknown;
                                if (input.ReadEnum(ref result.scheduleRelationship_, out unknown))
                                {
                                    result.hasScheduleRelationship = true;
                                }
                                else if (unknown is int)
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    unknownFields.MergeVarintField(4, (ulong)(int)unknown);
                                }
                                break;
                            }
                        case 42:
                            {
                                result.hasRouteId = input.ReadString(ref result.routeId_);
                                break;
                            }
                        case 48:
                            {
                                result.hasDirectionId = input.ReadUInt32(ref result.directionId_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasTripId
            {
                get { return result.hasTripId; }
            }
            public string TripId
            {
                get { return result.TripId; }
                set { SetTripId(value); }
            }
            public Builder SetTripId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTripId = true;
                result.tripId_ = value;
                return this;
            }
            public Builder ClearTripId()
            {
                PrepareBuilder();
                result.hasTripId = false;
                result.tripId_ = "";
                return this;
            }

            public bool HasRouteId
            {
                get { return result.hasRouteId; }
            }
            public string RouteId
            {
                get { return result.RouteId; }
                set { SetRouteId(value); }
            }
            public Builder SetRouteId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasRouteId = true;
                result.routeId_ = value;
                return this;
            }
            public Builder ClearRouteId()
            {
                PrepareBuilder();
                result.hasRouteId = false;
                result.routeId_ = "";
                return this;
            }

            public bool HasDirectionId
            {
                get { return result.hasDirectionId; }
            }
            [global::System.CLSCompliant(false)]
            public uint DirectionId
            {
                get { return result.DirectionId; }
                set { SetDirectionId(value); }
            }
            [global::System.CLSCompliant(false)]
            public Builder SetDirectionId(uint value)
            {
                PrepareBuilder();
                result.hasDirectionId = true;
                result.directionId_ = value;
                return this;
            }
            public Builder ClearDirectionId()
            {
                PrepareBuilder();
                result.hasDirectionId = false;
                result.directionId_ = 0;
                return this;
            }

            public bool HasStartTime
            {
                get { return result.hasStartTime; }
            }
            public string StartTime
            {
                get { return result.StartTime; }
                set { SetStartTime(value); }
            }
            public Builder SetStartTime(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStartTime = true;
                result.startTime_ = value;
                return this;
            }
            public Builder ClearStartTime()
            {
                PrepareBuilder();
                result.hasStartTime = false;
                result.startTime_ = "";
                return this;
            }

            public bool HasStartDate
            {
                get { return result.hasStartDate; }
            }
            public string StartDate
            {
                get { return result.StartDate; }
                set { SetStartDate(value); }
            }
            public Builder SetStartDate(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStartDate = true;
                result.startDate_ = value;
                return this;
            }
            public Builder ClearStartDate()
            {
                PrepareBuilder();
                result.hasStartDate = false;
                result.startDate_ = "";
                return this;
            }

            public bool HasScheduleRelationship
            {
                get { return result.hasScheduleRelationship; }
            }
            public global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship ScheduleRelationship
            {
                get { return result.ScheduleRelationship; }
                set { SetScheduleRelationship(value); }
            }
            public Builder SetScheduleRelationship(global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship value)
            {
                PrepareBuilder();
                result.hasScheduleRelationship = true;
                result.scheduleRelationship_ = value;
                return this;
            }
            public Builder ClearScheduleRelationship()
            {
                PrepareBuilder();
                result.hasScheduleRelationship = false;
                result.scheduleRelationship_ = global::TransitRealtime.TripDescriptor.Types.ScheduleRelationship.SCHEDULED;
                return this;
            }
        }
        static TripDescriptor()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class VehicleDescriptor : pb::ExtendableMessage<VehicleDescriptor, VehicleDescriptor.Builder>
    {
        private VehicleDescriptor() { }
        private static readonly VehicleDescriptor defaultInstance = new VehicleDescriptor().MakeReadOnly();
        private static readonly string[] _vehicleDescriptorFieldNames = new string[] { "id", "label", "license_plate" };
        private static readonly uint[] _vehicleDescriptorFieldTags = new uint[] { 10, 18, 26 };
        public static VehicleDescriptor DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override VehicleDescriptor DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override VehicleDescriptor ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_VehicleDescriptor__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<VehicleDescriptor, VehicleDescriptor.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_VehicleDescriptor__FieldAccessorTable; }
        }

        public const int IdFieldNumber = 1;
        private bool hasId;
        private string id_ = "";
        public bool HasId
        {
            get { return hasId; }
        }
        public string Id
        {
            get { return id_; }
        }

        public const int LabelFieldNumber = 2;
        private bool hasLabel;
        private string label_ = "";
        public bool HasLabel
        {
            get { return hasLabel; }
        }
        public string Label
        {
            get { return label_; }
        }

        public const int LicensePlateFieldNumber = 3;
        private bool hasLicensePlate;
        private string licensePlate_ = "";
        public bool HasLicensePlate
        {
            get { return hasLicensePlate; }
        }
        public string LicensePlate
        {
            get { return licensePlate_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _vehicleDescriptorFieldNames;
            pb::ExtendableMessage<VehicleDescriptor, VehicleDescriptor.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasId)
            {
                output.WriteString(1, field_names[0], Id);
            }
            if (hasLabel)
            {
                output.WriteString(2, field_names[1], Label);
            }
            if (hasLicensePlate)
            {
                output.WriteString(3, field_names[2], LicensePlate);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(1, Id);
            }
            if (hasLabel)
            {
                size += pb::CodedOutputStream.ComputeStringSize(2, Label);
            }
            if (hasLicensePlate)
            {
                size += pb::CodedOutputStream.ComputeStringSize(3, LicensePlate);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static VehicleDescriptor ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static VehicleDescriptor ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static VehicleDescriptor ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static VehicleDescriptor ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private VehicleDescriptor MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(VehicleDescriptor prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<VehicleDescriptor, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(VehicleDescriptor cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private VehicleDescriptor result;

            private VehicleDescriptor PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    VehicleDescriptor original = result;
                    result = new VehicleDescriptor();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override VehicleDescriptor MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.VehicleDescriptor.Descriptor; }
            }

            public override VehicleDescriptor DefaultInstanceForType
            {
                get { return global::TransitRealtime.VehicleDescriptor.DefaultInstance; }
            }

            public override VehicleDescriptor BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is VehicleDescriptor)
                {
                    return MergeFrom((VehicleDescriptor)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(VehicleDescriptor other)
            {
                if (other == global::TransitRealtime.VehicleDescriptor.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasId)
                {
                    Id = other.Id;
                }
                if (other.HasLabel)
                {
                    Label = other.Label;
                }
                if (other.HasLicensePlate)
                {
                    LicensePlate = other.LicensePlate;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_vehicleDescriptorFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _vehicleDescriptorFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                result.hasId = input.ReadString(ref result.id_);
                                break;
                            }
                        case 18:
                            {
                                result.hasLabel = input.ReadString(ref result.label_);
                                break;
                            }
                        case 26:
                            {
                                result.hasLicensePlate = input.ReadString(ref result.licensePlate_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasId
            {
                get { return result.hasId; }
            }
            public string Id
            {
                get { return result.Id; }
                set { SetId(value); }
            }
            public Builder SetId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasId = true;
                result.id_ = value;
                return this;
            }
            public Builder ClearId()
            {
                PrepareBuilder();
                result.hasId = false;
                result.id_ = "";
                return this;
            }

            public bool HasLabel
            {
                get { return result.hasLabel; }
            }
            public string Label
            {
                get { return result.Label; }
                set { SetLabel(value); }
            }
            public Builder SetLabel(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasLabel = true;
                result.label_ = value;
                return this;
            }
            public Builder ClearLabel()
            {
                PrepareBuilder();
                result.hasLabel = false;
                result.label_ = "";
                return this;
            }

            public bool HasLicensePlate
            {
                get { return result.hasLicensePlate; }
            }
            public string LicensePlate
            {
                get { return result.LicensePlate; }
                set { SetLicensePlate(value); }
            }
            public Builder SetLicensePlate(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasLicensePlate = true;
                result.licensePlate_ = value;
                return this;
            }
            public Builder ClearLicensePlate()
            {
                PrepareBuilder();
                result.hasLicensePlate = false;
                result.licensePlate_ = "";
                return this;
            }
        }
        static VehicleDescriptor()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class EntitySelector : pb::ExtendableMessage<EntitySelector, EntitySelector.Builder>
    {
        private EntitySelector() { }
        private static readonly EntitySelector defaultInstance = new EntitySelector().MakeReadOnly();
        private static readonly string[] _entitySelectorFieldNames = new string[] { "agency_id", "route_id", "route_type", "stop_id", "trip" };
        private static readonly uint[] _entitySelectorFieldTags = new uint[] { 10, 18, 24, 42, 34 };
        public static EntitySelector DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override EntitySelector DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override EntitySelector ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_EntitySelector__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<EntitySelector, EntitySelector.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_EntitySelector__FieldAccessorTable; }
        }

        public const int AgencyIdFieldNumber = 1;
        private bool hasAgencyId;
        private string agencyId_ = "";
        public bool HasAgencyId
        {
            get { return hasAgencyId; }
        }
        public string AgencyId
        {
            get { return agencyId_; }
        }

        public const int RouteIdFieldNumber = 2;
        private bool hasRouteId;
        private string routeId_ = "";
        public bool HasRouteId
        {
            get { return hasRouteId; }
        }
        public string RouteId
        {
            get { return routeId_; }
        }

        public const int RouteTypeFieldNumber = 3;
        private bool hasRouteType;
        private int routeType_;
        public bool HasRouteType
        {
            get { return hasRouteType; }
        }
        public int RouteType
        {
            get { return routeType_; }
        }

        public const int TripFieldNumber = 4;
        private bool hasTrip;
        private global::TransitRealtime.TripDescriptor trip_;
        public bool HasTrip
        {
            get { return hasTrip; }
        }
        public global::TransitRealtime.TripDescriptor Trip
        {
            get { return trip_ ?? global::TransitRealtime.TripDescriptor.DefaultInstance; }
        }

        public const int StopIdFieldNumber = 5;
        private bool hasStopId;
        private string stopId_ = "";
        public bool HasStopId
        {
            get { return hasStopId; }
        }
        public string StopId
        {
            get { return stopId_; }
        }

        public override bool IsInitialized
        {
            get
            {
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _entitySelectorFieldNames;
            pb::ExtendableMessage<EntitySelector, EntitySelector.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (hasAgencyId)
            {
                output.WriteString(1, field_names[0], AgencyId);
            }
            if (hasRouteId)
            {
                output.WriteString(2, field_names[1], RouteId);
            }
            if (hasRouteType)
            {
                output.WriteInt32(3, field_names[2], RouteType);
            }
            if (hasTrip)
            {
                output.WriteMessage(4, field_names[4], Trip);
            }
            if (hasStopId)
            {
                output.WriteString(5, field_names[3], StopId);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            if (hasAgencyId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(1, AgencyId);
            }
            if (hasRouteId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(2, RouteId);
            }
            if (hasRouteType)
            {
                size += pb::CodedOutputStream.ComputeInt32Size(3, RouteType);
            }
            if (hasTrip)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(4, Trip);
            }
            if (hasStopId)
            {
                size += pb::CodedOutputStream.ComputeStringSize(5, StopId);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static EntitySelector ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static EntitySelector ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static EntitySelector ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static EntitySelector ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static EntitySelector ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static EntitySelector ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static EntitySelector ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static EntitySelector ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static EntitySelector ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static EntitySelector ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private EntitySelector MakeReadOnly()
        {
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(EntitySelector prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<EntitySelector, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(EntitySelector cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private EntitySelector result;

            private EntitySelector PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    EntitySelector original = result;
                    result = new EntitySelector();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override EntitySelector MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.EntitySelector.Descriptor; }
            }

            public override EntitySelector DefaultInstanceForType
            {
                get { return global::TransitRealtime.EntitySelector.DefaultInstance; }
            }

            public override EntitySelector BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is EntitySelector)
                {
                    return MergeFrom((EntitySelector)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(EntitySelector other)
            {
                if (other == global::TransitRealtime.EntitySelector.DefaultInstance) return this;
                PrepareBuilder();
                if (other.HasAgencyId)
                {
                    AgencyId = other.AgencyId;
                }
                if (other.HasRouteId)
                {
                    RouteId = other.RouteId;
                }
                if (other.HasRouteType)
                {
                    RouteType = other.RouteType;
                }
                if (other.HasTrip)
                {
                    MergeTrip(other.Trip);
                }
                if (other.HasStopId)
                {
                    StopId = other.StopId;
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_entitySelectorFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _entitySelectorFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                result.hasAgencyId = input.ReadString(ref result.agencyId_);
                                break;
                            }
                        case 18:
                            {
                                result.hasRouteId = input.ReadString(ref result.routeId_);
                                break;
                            }
                        case 24:
                            {
                                result.hasRouteType = input.ReadInt32(ref result.routeType_);
                                break;
                            }
                        case 34:
                            {
                                global::TransitRealtime.TripDescriptor.Builder subBuilder = global::TransitRealtime.TripDescriptor.CreateBuilder();
                                if (result.hasTrip)
                                {
                                    subBuilder.MergeFrom(Trip);
                                }
                                input.ReadMessage(subBuilder, extensionRegistry);
                                Trip = subBuilder.BuildPartial();
                                break;
                            }
                        case 42:
                            {
                                result.hasStopId = input.ReadString(ref result.stopId_);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public bool HasAgencyId
            {
                get { return result.hasAgencyId; }
            }
            public string AgencyId
            {
                get { return result.AgencyId; }
                set { SetAgencyId(value); }
            }
            public Builder SetAgencyId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasAgencyId = true;
                result.agencyId_ = value;
                return this;
            }
            public Builder ClearAgencyId()
            {
                PrepareBuilder();
                result.hasAgencyId = false;
                result.agencyId_ = "";
                return this;
            }

            public bool HasRouteId
            {
                get { return result.hasRouteId; }
            }
            public string RouteId
            {
                get { return result.RouteId; }
                set { SetRouteId(value); }
            }
            public Builder SetRouteId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasRouteId = true;
                result.routeId_ = value;
                return this;
            }
            public Builder ClearRouteId()
            {
                PrepareBuilder();
                result.hasRouteId = false;
                result.routeId_ = "";
                return this;
            }

            public bool HasRouteType
            {
                get { return result.hasRouteType; }
            }
            public int RouteType
            {
                get { return result.RouteType; }
                set { SetRouteType(value); }
            }
            public Builder SetRouteType(int value)
            {
                PrepareBuilder();
                result.hasRouteType = true;
                result.routeType_ = value;
                return this;
            }
            public Builder ClearRouteType()
            {
                PrepareBuilder();
                result.hasRouteType = false;
                result.routeType_ = 0;
                return this;
            }

            public bool HasTrip
            {
                get { return result.hasTrip; }
            }
            public global::TransitRealtime.TripDescriptor Trip
            {
                get { return result.Trip; }
                set { SetTrip(value); }
            }
            public Builder SetTrip(global::TransitRealtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = value;
                return this;
            }
            public Builder SetTrip(global::TransitRealtime.TripDescriptor.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.hasTrip = true;
                result.trip_ = builderForValue.Build();
                return this;
            }
            public Builder MergeTrip(global::TransitRealtime.TripDescriptor value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                if (result.hasTrip &&
                    result.trip_ != global::TransitRealtime.TripDescriptor.DefaultInstance)
                {
                    result.trip_ = global::TransitRealtime.TripDescriptor.CreateBuilder(result.trip_).MergeFrom(value).BuildPartial();
                }
                else
                {
                    result.trip_ = value;
                }
                result.hasTrip = true;
                return this;
            }
            public Builder ClearTrip()
            {
                PrepareBuilder();
                result.hasTrip = false;
                result.trip_ = null;
                return this;
            }

            public bool HasStopId
            {
                get { return result.hasStopId; }
            }
            public string StopId
            {
                get { return result.StopId; }
                set { SetStopId(value); }
            }
            public Builder SetStopId(string value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.hasStopId = true;
                result.stopId_ = value;
                return this;
            }
            public Builder ClearStopId()
            {
                PrepareBuilder();
                result.hasStopId = false;
                result.stopId_ = "";
                return this;
            }
        }
        static EntitySelector()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class TranslatedString : pb::ExtendableMessage<TranslatedString, TranslatedString.Builder>
    {
        private TranslatedString() { }
        private static readonly TranslatedString defaultInstance = new TranslatedString().MakeReadOnly();
        private static readonly string[] _translatedStringFieldNames = new string[] { "translation" };
        private static readonly uint[] _translatedStringFieldTags = new uint[] { 10 };
        public static TranslatedString DefaultInstance
        {
            get { return defaultInstance; }
        }

        public override TranslatedString DefaultInstanceForType
        {
            get { return DefaultInstance; }
        }

        protected override TranslatedString ThisMessage
        {
            get { return this; }
        }

        public static pbd::MessageDescriptor Descriptor
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TranslatedString__Descriptor; }
        }

        protected override pb::FieldAccess.FieldAccessorTable<TranslatedString, TranslatedString.Builder> InternalFieldAccessors
        {
            get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TranslatedString__FieldAccessorTable; }
        }

        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public static partial class Types
        {
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
            public sealed partial class Translation : pb::ExtendableMessage<Translation, Translation.Builder>
            {
                private Translation() { }
                private static readonly Translation defaultInstance = new Translation().MakeReadOnly();
                private static readonly string[] _translationFieldNames = new string[] { "language", "text" };
                private static readonly uint[] _translationFieldTags = new uint[] { 18, 10 };
                public static Translation DefaultInstance
                {
                    get { return defaultInstance; }
                }

                public override Translation DefaultInstanceForType
                {
                    get { return DefaultInstance; }
                }

                protected override Translation ThisMessage
                {
                    get { return this; }
                }

                public static pbd::MessageDescriptor Descriptor
                {
                    get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TranslatedString_Translation__Descriptor; }
                }

                protected override pb::FieldAccess.FieldAccessorTable<Translation, Translation.Builder> InternalFieldAccessors
                {
                    get { return global::TransitRealtime.GTFSRealtime.internal__static_transit_realtime_TranslatedString_Translation__FieldAccessorTable; }
                }

                public const int TextFieldNumber = 1;
                private bool hasText;
                private string text_ = "";
                public bool HasText
                {
                    get { return hasText; }
                }
                public string Text
                {
                    get { return text_; }
                }

                public const int LanguageFieldNumber = 2;
                private bool hasLanguage;
                private string language_ = "";
                public bool HasLanguage
                {
                    get { return hasLanguage; }
                }
                public string Language
                {
                    get { return language_; }
                }

                public override bool IsInitialized
                {
                    get
                    {
                        if (!hasText) return false;
                        if (!ExtensionsAreInitialized) return false;
                        return true;
                    }
                }

                public override void WriteTo(pb::ICodedOutputStream output)
                {
                    CalcSerializedSize();
                    string[] field_names = _translationFieldNames;
                    pb::ExtendableMessage<Translation, Translation.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
                    if (hasText)
                    {
                        output.WriteString(1, field_names[1], Text);
                    }
                    if (hasLanguage)
                    {
                        output.WriteString(2, field_names[0], Language);
                    }
                    extensionWriter.WriteUntil(2000, output);
                    UnknownFields.WriteTo(output);
                }

                private int memoizedSerializedSize = -1;
                public override int SerializedSize
                {
                    get
                    {
                        int size = memoizedSerializedSize;
                        if (size != -1) return size;
                        return CalcSerializedSize();
                    }
                }

                private int CalcSerializedSize()
                {
                    int size = memoizedSerializedSize;
                    if (size != -1) return size;

                    size = 0;
                    if (hasText)
                    {
                        size += pb::CodedOutputStream.ComputeStringSize(1, Text);
                    }
                    if (hasLanguage)
                    {
                        size += pb::CodedOutputStream.ComputeStringSize(2, Language);
                    }
                    size += ExtensionsSerializedSize;
                    size += UnknownFields.SerializedSize;
                    memoizedSerializedSize = size;
                    return size;
                }
                public static Translation ParseFrom(pb::ByteString data)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
                }
                public static Translation ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }
                public static Translation ParseFrom(byte[] data)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
                }
                public static Translation ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
                }
                public static Translation ParseFrom(global::System.IO.Stream input)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
                }
                public static Translation ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }
                public static Translation ParseDelimitedFrom(global::System.IO.Stream input)
                {
                    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
                }
                public static Translation ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
                }
                public static Translation ParseFrom(pb::ICodedInputStream input)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
                }
                public static Translation ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                {
                    return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
                }
                private Translation MakeReadOnly()
                {
                    return this;
                }

                public static Builder CreateBuilder() { return new Builder(); }
                public override Builder ToBuilder() { return CreateBuilder(this); }
                public override Builder CreateBuilderForType() { return new Builder(); }
                public static Builder CreateBuilder(Translation prototype)
                {
                    return new Builder(prototype);
                }

                [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
                public sealed partial class Builder : pb::ExtendableBuilder<Translation, Builder>
                {
                    protected override Builder ThisBuilder
                    {
                        get { return this; }
                    }
                    public Builder()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                    }
                    internal Builder(Translation cloneFrom)
                    {
                        result = cloneFrom;
                        resultIsReadOnly = true;
                    }

                    private bool resultIsReadOnly;
                    private Translation result;

                    private Translation PrepareBuilder()
                    {
                        if (resultIsReadOnly)
                        {
                            Translation original = result;
                            result = new Translation();
                            resultIsReadOnly = false;
                            MergeFrom(original);
                        }
                        return result;
                    }

                    public override bool IsInitialized
                    {
                        get { return result.IsInitialized; }
                    }

                    protected override Translation MessageBeingBuilt
                    {
                        get { return PrepareBuilder(); }
                    }

                    public override Builder Clear()
                    {
                        result = DefaultInstance;
                        resultIsReadOnly = true;
                        return this;
                    }

                    public override Builder Clone()
                    {
                        if (resultIsReadOnly)
                        {
                            return new Builder(result);
                        }
                        else
                        {
                            return new Builder().MergeFrom(result);
                        }
                    }

                    public override pbd::MessageDescriptor DescriptorForType
                    {
                        get { return global::TransitRealtime.TranslatedString.Types.Translation.Descriptor; }
                    }

                    public override Translation DefaultInstanceForType
                    {
                        get { return global::TransitRealtime.TranslatedString.Types.Translation.DefaultInstance; }
                    }

                    public override Translation BuildPartial()
                    {
                        if (resultIsReadOnly)
                        {
                            return result;
                        }
                        resultIsReadOnly = true;
                        return result.MakeReadOnly();
                    }

                    public override Builder MergeFrom(pb::IMessage other)
                    {
                        if (other is Translation)
                        {
                            return MergeFrom((Translation)other);
                        }
                        else
                        {
                            base.MergeFrom(other);
                            return this;
                        }
                    }

                    public override Builder MergeFrom(Translation other)
                    {
                        if (other == global::TransitRealtime.TranslatedString.Types.Translation.DefaultInstance) return this;
                        PrepareBuilder();
                        if (other.HasText)
                        {
                            Text = other.Text;
                        }
                        if (other.HasLanguage)
                        {
                            Language = other.Language;
                        }
                        this.MergeExtensionFields(other);
                        this.MergeUnknownFields(other.UnknownFields);
                        return this;
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input)
                    {
                        return MergeFrom(input, pb::ExtensionRegistry.Empty);
                    }

                    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
                    {
                        PrepareBuilder();
                        pb::UnknownFieldSet.Builder unknownFields = null;
                        uint tag;
                        string field_name;
                        while (input.ReadTag(out tag, out field_name))
                        {
                            if (tag == 0 && field_name != null)
                            {
                                int field_ordinal = global::System.Array.BinarySearch(_translationFieldNames, field_name, global::System.StringComparer.Ordinal);
                                if (field_ordinal >= 0)
                                    tag = _translationFieldTags[field_ordinal];
                                else
                                {
                                    if (unknownFields == null)
                                    {
                                        unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                    }
                                    ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                    continue;
                                }
                            }
                            switch (tag)
                            {
                                case 0:
                                    {
                                        throw pb::InvalidProtocolBufferException.InvalidTag();
                                    }
                                default:
                                    {
                                        if (pb::WireFormat.IsEndGroupTag(tag))
                                        {
                                            if (unknownFields != null)
                                            {
                                                this.UnknownFields = unknownFields.Build();
                                            }
                                            return this;
                                        }
                                        if (unknownFields == null)
                                        {
                                            unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                        }
                                        ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                        break;
                                    }
                                case 10:
                                    {
                                        result.hasText = input.ReadString(ref result.text_);
                                        break;
                                    }
                                case 18:
                                    {
                                        result.hasLanguage = input.ReadString(ref result.language_);
                                        break;
                                    }
                            }
                        }

                        if (unknownFields != null)
                        {
                            this.UnknownFields = unknownFields.Build();
                        }
                        return this;
                    }


                    public bool HasText
                    {
                        get { return result.hasText; }
                    }
                    public string Text
                    {
                        get { return result.Text; }
                        set { SetText(value); }
                    }
                    public Builder SetText(string value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasText = true;
                        result.text_ = value;
                        return this;
                    }
                    public Builder ClearText()
                    {
                        PrepareBuilder();
                        result.hasText = false;
                        result.text_ = "";
                        return this;
                    }

                    public bool HasLanguage
                    {
                        get { return result.hasLanguage; }
                    }
                    public string Language
                    {
                        get { return result.Language; }
                        set { SetLanguage(value); }
                    }
                    public Builder SetLanguage(string value)
                    {
                        pb::ThrowHelper.ThrowIfNull(value, "value");
                        PrepareBuilder();
                        result.hasLanguage = true;
                        result.language_ = value;
                        return this;
                    }
                    public Builder ClearLanguage()
                    {
                        PrepareBuilder();
                        result.hasLanguage = false;
                        result.language_ = "";
                        return this;
                    }
                }
                static Translation()
                {
                    object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
                }
            }

        }
        #endregion

        public const int TranslationFieldNumber = 1;
        private pbc::PopsicleList<global::TransitRealtime.TranslatedString.Types.Translation> translation_ = new pbc::PopsicleList<global::TransitRealtime.TranslatedString.Types.Translation>();
        public scg::IList<global::TransitRealtime.TranslatedString.Types.Translation> TranslationList
        {
            get { return translation_; }
        }
        public int TranslationCount
        {
            get { return translation_.Count; }
        }
        public global::TransitRealtime.TranslatedString.Types.Translation GetTranslation(int index)
        {
            return translation_[index];
        }

        public override bool IsInitialized
        {
            get
            {
                foreach (global::TransitRealtime.TranslatedString.Types.Translation element in TranslationList)
                {
                    if (!element.IsInitialized) return false;
                }
                if (!ExtensionsAreInitialized) return false;
                return true;
            }
        }

        public override void WriteTo(pb::ICodedOutputStream output)
        {
            CalcSerializedSize();
            string[] field_names = _translatedStringFieldNames;
            pb::ExtendableMessage<TranslatedString, TranslatedString.Builder>.ExtensionWriter extensionWriter = CreateExtensionWriter(this);
            if (translation_.Count > 0)
            {
                output.WriteMessageArray(1, field_names[0], translation_);
            }
            extensionWriter.WriteUntil(2000, output);
            UnknownFields.WriteTo(output);
        }

        private int memoizedSerializedSize = -1;
        public override int SerializedSize
        {
            get
            {
                int size = memoizedSerializedSize;
                if (size != -1) return size;
                return CalcSerializedSize();
            }
        }

        private int CalcSerializedSize()
        {
            int size = memoizedSerializedSize;
            if (size != -1) return size;

            size = 0;
            foreach (global::TransitRealtime.TranslatedString.Types.Translation element in TranslationList)
            {
                size += pb::CodedOutputStream.ComputeMessageSize(1, element);
            }
            size += ExtensionsSerializedSize;
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
        }
        public static TranslatedString ParseFrom(pb::ByteString data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TranslatedString ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TranslatedString ParseFrom(byte[] data)
        {
            return ((Builder)CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static TranslatedString ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static TranslatedString ParseFrom(global::System.IO.Stream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TranslatedString ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static TranslatedString ParseDelimitedFrom(global::System.IO.Stream input)
        {
            return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static TranslatedString ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry)
        {
            return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static TranslatedString ParseFrom(pb::ICodedInputStream input)
        {
            return ((Builder)CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static TranslatedString ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
        {
            return ((Builder)CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private TranslatedString MakeReadOnly()
        {
            translation_.MakeReadOnly();
            return this;
        }

        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(TranslatedString prototype)
        {
            return new Builder(prototype);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::ExtendableBuilder<TranslatedString, Builder>
        {
            protected override Builder ThisBuilder
            {
                get { return this; }
            }
            public Builder()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
            }
            internal Builder(TranslatedString cloneFrom)
            {
                result = cloneFrom;
                resultIsReadOnly = true;
            }

            private bool resultIsReadOnly;
            private TranslatedString result;

            private TranslatedString PrepareBuilder()
            {
                if (resultIsReadOnly)
                {
                    TranslatedString original = result;
                    result = new TranslatedString();
                    resultIsReadOnly = false;
                    MergeFrom(original);
                }
                return result;
            }

            public override bool IsInitialized
            {
                get { return result.IsInitialized; }
            }

            protected override TranslatedString MessageBeingBuilt
            {
                get { return PrepareBuilder(); }
            }

            public override Builder Clear()
            {
                result = DefaultInstance;
                resultIsReadOnly = true;
                return this;
            }

            public override Builder Clone()
            {
                if (resultIsReadOnly)
                {
                    return new Builder(result);
                }
                else
                {
                    return new Builder().MergeFrom(result);
                }
            }

            public override pbd::MessageDescriptor DescriptorForType
            {
                get { return global::TransitRealtime.TranslatedString.Descriptor; }
            }

            public override TranslatedString DefaultInstanceForType
            {
                get { return global::TransitRealtime.TranslatedString.DefaultInstance; }
            }

            public override TranslatedString BuildPartial()
            {
                if (resultIsReadOnly)
                {
                    return result;
                }
                resultIsReadOnly = true;
                return result.MakeReadOnly();
            }

            public override Builder MergeFrom(pb::IMessage other)
            {
                if (other is TranslatedString)
                {
                    return MergeFrom((TranslatedString)other);
                }
                else
                {
                    base.MergeFrom(other);
                    return this;
                }
            }

            public override Builder MergeFrom(TranslatedString other)
            {
                if (other == global::TransitRealtime.TranslatedString.DefaultInstance) return this;
                PrepareBuilder();
                if (other.translation_.Count != 0)
                {
                    result.translation_.Add(other.translation_);
                }
                this.MergeExtensionFields(other);
                this.MergeUnknownFields(other.UnknownFields);
                return this;
            }

            public override Builder MergeFrom(pb::ICodedInputStream input)
            {
                return MergeFrom(input, pb::ExtensionRegistry.Empty);
            }

            public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry)
            {
                PrepareBuilder();
                pb::UnknownFieldSet.Builder unknownFields = null;
                uint tag;
                string field_name;
                while (input.ReadTag(out tag, out field_name))
                {
                    if (tag == 0 && field_name != null)
                    {
                        int field_ordinal = global::System.Array.BinarySearch(_translatedStringFieldNames, field_name, global::System.StringComparer.Ordinal);
                        if (field_ordinal >= 0)
                            tag = _translatedStringFieldTags[field_ordinal];
                        else
                        {
                            if (unknownFields == null)
                            {
                                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                            }
                            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                            continue;
                        }
                    }
                    switch (tag)
                    {
                        case 0:
                            {
                                throw pb::InvalidProtocolBufferException.InvalidTag();
                            }
                        default:
                            {
                                if (pb::WireFormat.IsEndGroupTag(tag))
                                {
                                    if (unknownFields != null)
                                    {
                                        this.UnknownFields = unknownFields.Build();
                                    }
                                    return this;
                                }
                                if (unknownFields == null)
                                {
                                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                                }
                                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                                break;
                            }
                        case 10:
                            {
                                input.ReadMessageArray(tag, field_name, result.translation_, global::TransitRealtime.TranslatedString.Types.Translation.DefaultInstance, extensionRegistry);
                                break;
                            }
                    }
                }

                if (unknownFields != null)
                {
                    this.UnknownFields = unknownFields.Build();
                }
                return this;
            }


            public pbc::IPopsicleList<global::TransitRealtime.TranslatedString.Types.Translation> TranslationList
            {
                get { return PrepareBuilder().translation_; }
            }
            public int TranslationCount
            {
                get { return result.TranslationCount; }
            }
            public global::TransitRealtime.TranslatedString.Types.Translation GetTranslation(int index)
            {
                return result.GetTranslation(index);
            }
            public Builder SetTranslation(int index, global::TransitRealtime.TranslatedString.Types.Translation value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.translation_[index] = value;
                return this;
            }
            public Builder SetTranslation(int index, global::TransitRealtime.TranslatedString.Types.Translation.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.translation_[index] = builderForValue.Build();
                return this;
            }
            public Builder AddTranslation(global::TransitRealtime.TranslatedString.Types.Translation value)
            {
                pb::ThrowHelper.ThrowIfNull(value, "value");
                PrepareBuilder();
                result.translation_.Add(value);
                return this;
            }
            public Builder AddTranslation(global::TransitRealtime.TranslatedString.Types.Translation.Builder builderForValue)
            {
                pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
                PrepareBuilder();
                result.translation_.Add(builderForValue.Build());
                return this;
            }
            public Builder AddRangeTranslation(scg::IEnumerable<global::TransitRealtime.TranslatedString.Types.Translation> values)
            {
                PrepareBuilder();
                result.translation_.Add(values);
                return this;
            }
            public Builder ClearTranslation()
            {
                PrepareBuilder();
                result.translation_.Clear();
                return this;
            }
        }
        static TranslatedString()
        {
            object.ReferenceEquals(global::TransitRealtime.GTFSRealtime.Descriptor, null);
        }
    }

    #endregion

}

#endregion Designer generated code
